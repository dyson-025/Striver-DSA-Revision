🟢 Minimum Path Sum in a Grid (DP – 10)
link: https://leetcode.com/problems/minimum-path-sum/
✅ Mark as Completed
🔢 Score: 61

📌 Problem Description

We are given an N × M grid of integers.
Each cell contains a cost. We must start from the top-left corner (0,0) and reach the bottom-right corner (N-1, M-1).

We can only move in two directions:

Right (→)

Down (↓)

The path cost is the sum of the values of all visited cells.
Our task is to find the minimum possible path sum.

📊 Example
Example 1:

Input Grid:

5   9   6
11  5   2


Possible paths:

Path 1: 5 → 9 → 6 → 2 = 22

Path 2: 5 → 9 → 5 → 2 = 21 ✅ (minimum)

Path 3: 5 → 11 → 5 → 2 = 23

Output:

21

🚫 Why Not Greedy?

A greedy approach suggests always picking the cheaper option at every step.
But this fails because a locally optimal choice may block the globally optimal path.

Example:

1   99
1   1


Greedy path: 1 → 99 → 1 = 101 ❌

Optimal path: 1 → 1 → 1 = 3 ✅

So, greedy doesn’t work. We need Dynamic Programming.

🧩 Recursive Approach (Top-Down)

We define a function:
f(i, j) = Minimum path sum to reach cell (i, j) from (0, 0).

🔑 Base Cases:

If (i, j) == (0, 0): return grid[0][0].

If i < 0 or j < 0: return ∞ (invalid path).

🔑 Transition:

At each (i, j), we can come from:

Top: (i-1, j)

Left: (i, j-1)

So,

f(i, j) = grid[i][j] + min(f(i-1, j), f(i, j-1))

🖥️ Recursive + Memoization Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathUtil(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    if (i == 0 && j == 0) return grid[0][0];   // Base case
    if (i < 0 || j < 0) return INT_MAX;        // Out of bounds
    if (dp[i][j] != -1) return dp[i][j];       // Already computed

    int up = grid[i][j] + minPathUtil(i - 1, j, grid, dp);
    int left = grid[i][j] + minPathUtil(i, j - 1, grid, dp);

    return dp[i][j] = min(up, left);
}

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, -1));
    return minPathUtil(n - 1, m - 1, grid, dp);
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


✅ Output: 21

⏳ Complexity (Memoization)

Time: O(N*M) (each state solved once)

Space: O(N*M) (DP table) + O(N+M) (recursion stack)

📋 Tabulation (Bottom-Up DP)

We build the DP table iteratively.

Transition:
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

🖥️ Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, 0));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0) dp[i][j] = grid[i][j];
            else {
                int up = grid[i][j];
                if (i > 0) up += dp[i-1][j]; else up += 1e9;
                
                int left = grid[i][j];
                if (j > 0) left += dp[i][j-1]; else left += 1e9;

                dp[i][j] = min(up, left);
            }
        }
    }
    return dp[n-1][m-1];
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


✅ Output: 21

⏳ Complexity (Tabulation)

Time: O(N*M)

Space: O(N*M)

💾 Space Optimization

We don’t need the whole DP table — only the previous row.

🖥️ Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<int> prev(m, 0);

    for (int i = 0; i < n; i++) {
        vector<int> temp(m, 0);
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0) temp[j] = grid[i][j];
            else {
                int up = grid[i][j];
                if (i > 0) up += prev[j]; else up += 1e9;

                int left = grid[i][j];
                if (j > 0) left += temp[j-1]; else left += 1e9;

                temp[j] = min(up, left);
            }
        }
        prev = temp;
    }
    return prev[m-1];
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


✅ Output: 21

⏳ Complexity (Optimized)

Time: O(N*M)

Space: O(M)

⚡ Final Notes

Recursive + Memoization: good for learning.

Tabulation: clean and efficient.

Space Optimized: best for interviews (O(M) space).

👉 This problem is a classic DP on grids — once you master it, you can extend it to maximum path sum, triangle minimum path, grid paths with obstacles, etc.
