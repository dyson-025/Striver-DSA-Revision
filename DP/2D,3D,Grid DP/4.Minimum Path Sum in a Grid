ğŸŸ¢ Minimum Path Sum in a Grid (DP â€“ 10)
link: https://leetcode.com/problems/minimum-path-sum/
âœ… Mark as Completed
ğŸ”¢ Score: 61

ğŸ“Œ Problem Description

We are given an N Ã— M grid of integers.
Each cell contains a cost. We must start from the top-left corner (0,0) and reach the bottom-right corner (N-1, M-1).

We can only move in two directions:

Right (â†’)

Down (â†“)

The path cost is the sum of the values of all visited cells.
Our task is to find the minimum possible path sum.

ğŸ“Š Example
Example 1:

Input Grid:

5   9   6
11  5   2


Possible paths:

Path 1: 5 â†’ 9 â†’ 6 â†’ 2 = 22

Path 2: 5 â†’ 9 â†’ 5 â†’ 2 = 21 âœ… (minimum)

Path 3: 5 â†’ 11 â†’ 5 â†’ 2 = 23

Output:

21

ğŸš« Why Not Greedy?

A greedy approach suggests always picking the cheaper option at every step.
But this fails because a locally optimal choice may block the globally optimal path.

Example:

1   99
1   1


Greedy path: 1 â†’ 99 â†’ 1 = 101 âŒ

Optimal path: 1 â†’ 1 â†’ 1 = 3 âœ…

So, greedy doesnâ€™t work. We need Dynamic Programming.

ğŸ§© Recursive Approach (Top-Down)

We define a function:
f(i, j) = Minimum path sum to reach cell (i, j) from (0, 0).

ğŸ”‘ Base Cases:

If (i, j) == (0, 0): return grid[0][0].

If i < 0 or j < 0: return âˆ (invalid path).

ğŸ”‘ Transition:

At each (i, j), we can come from:

Top: (i-1, j)

Left: (i, j-1)

So,

f(i, j) = grid[i][j] + min(f(i-1, j), f(i, j-1))

ğŸ–¥ï¸ Recursive + Memoization Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathUtil(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {
    if (i == 0 && j == 0) return grid[0][0];   // Base case
    if (i < 0 || j < 0) return INT_MAX;        // Out of bounds
    if (dp[i][j] != -1) return dp[i][j];       // Already computed

    int up = grid[i][j] + minPathUtil(i - 1, j, grid, dp);
    int left = grid[i][j] + minPathUtil(i, j - 1, grid, dp);

    return dp[i][j] = min(up, left);
}

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, -1));
    return minPathUtil(n - 1, m - 1, grid, dp);
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


âœ… Output: 21

â³ Complexity (Memoization)

Time: O(N*M) (each state solved once)

Space: O(N*M) (DP table) + O(N+M) (recursion stack)

ğŸ“‹ Tabulation (Bottom-Up DP)

We build the DP table iteratively.

Transition:
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

ğŸ–¥ï¸ Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m, 0));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0) dp[i][j] = grid[i][j];
            else {
                int up = grid[i][j];
                if (i > 0) up += dp[i-1][j]; else up += 1e9;
                
                int left = grid[i][j];
                if (j > 0) left += dp[i][j-1]; else left += 1e9;

                dp[i][j] = min(up, left);
            }
        }
    }
    return dp[n-1][m-1];
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


âœ… Output: 21

â³ Complexity (Tabulation)

Time: O(N*M)

Space: O(N*M)

ğŸ’¾ Space Optimization

We donâ€™t need the whole DP table â€” only the previous row.

ğŸ–¥ï¸ Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minPathSum(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<int> prev(m, 0);

    for (int i = 0; i < n; i++) {
        vector<int> temp(m, 0);
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0) temp[j] = grid[i][j];
            else {
                int up = grid[i][j];
                if (i > 0) up += prev[j]; else up += 1e9;

                int left = grid[i][j];
                if (j > 0) left += temp[j-1]; else left += 1e9;

                temp[j] = min(up, left);
            }
        }
        prev = temp;
    }
    return prev[m-1];
}

int main() {
    vector<vector<int>> grid = {{5, 9, 6}, {11, 5, 2}};
    cout << "Minimum Path Sum: " << minPathSum(grid) << endl;
}


âœ… Output: 21

â³ Complexity (Optimized)

Time: O(N*M)

Space: O(M)

âš¡ Final Notes

Recursive + Memoization: good for learning.

Tabulation: clean and efficient.

Space Optimized: best for interviews (O(M) space).

ğŸ‘‰ This problem is a classic DP on grids â€” once you master it, you can extend it to maximum path sum, triangle minimum path, grid paths with obstacles, etc.
