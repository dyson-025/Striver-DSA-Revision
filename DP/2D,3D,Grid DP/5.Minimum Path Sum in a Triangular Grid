ğŸŸ¢ Minimum Path Sum in a Triangular Grid (DP â€“ 11)
link: https://leetcode.com/problems/triangle/
âœ… Mark as Completed
ğŸ“Œ Score: 73

ğŸ“– Problem Statement

We are given a triangular matrix (triangle grid).
We need to find the minimum path sum from the top element (row 0, col 0) to any element in the last row.

ğŸ‘‰ At each cell, we can move in two directions only:

Down (â†“) â†’ triangle[i+1][j]

Down-Right (â†˜) â†’ triangle[i+1][j+1]

ğŸ”— Problem Link

Leetcode â€“ Triangle

This problem is also known as Fixed Starting and Ending Point.

ğŸ“Œ Example
Input Triangle:
     1
    2 3
   3 6 7
  8 9 6 10

Possible Paths:

1 â†’ 2 â†’ 3 â†’ 8 = 14

1 â†’ 2 â†’ 3 â†’ 9 = 15

1 â†’ 2 â†’ 6 â†’ 9 = 18

1 â†’ 3 â†’ 6 â†’ 9 = 19

1 â†’ 3 â†’ 7 â†’ 6 = 17

âœ… Answer = 14 (minimum path sum)

âš¡ Why Greedy Fails?

At every step, choosing the smaller of the two adjacent values does not guarantee a global minimum.
For example:

Greedy may pick 3 instead of 6, but in the next row, the sum might grow larger.
Hence, we need Dynamic Programming.

ğŸŸ¢ Step 1: Recursive Approach (Exponential âŒ)

We define a function f(i, j) = minimum path sum starting from (i, j) to the last row.

Base Case:
If i == n-1 (last row) â†’ return triangle[i][j]

Recursive Case:
From (i, j) we can move:

Down â†’ triangle[i][j] + f(i+1, j)

Diagonal â†’ triangle[i][j] + f(i+1, j+1)

Return: min(down, diagonal)

ğŸŸ¢ Step 2: Memoization (Top-Down DP)

We store results of overlapping subproblems in a dp[i][j] table.

C++ Code:
#include <bits/stdc++.h>
using namespace std;

int minimumPathSumUtil(int i, int j, vector<vector<int>>& triangle, int n, vector<vector<int>>& dp) {
    if (i == n - 1) return triangle[i][j];  // Base case: last row
    if (dp[i][j] != -1) return dp[i][j];    // Already computed

    int down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp);
    int diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp);

    return dp[i][j] = min(down, diagonal);
}

int minimumPathSum(vector<vector<int>>& triangle, int n) {
    vector<vector<int>> dp(n, vector<int>(n, -1));
    return minimumPathSumUtil(0, 0, triangle, n, dp);
}

int main() {
    vector<vector<int>> triangle{{1}, {2, 3}, {3, 6, 7}, {8, 9, 6, 10}};
    int n = triangle.size();
    cout << "Minimum Path Sum: " << minimumPathSum(triangle, n);
}

Output:
14

â± Complexity:

Time: O(NÂ²)

Space: O(NÂ²) (DP table) + O(N) (recursion stack)

ğŸŸ¢ Step 3: Tabulation (Bottom-Up DP)

Instead of recursion, we build from the last row upwards.

Intuition:

Last row values = base case

Each dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])

C++ Code:
#include <bits/stdc++.h>
using namespace std;

int minimumPathSum(vector<vector<int>>& triangle, int n) {
    vector<vector<int>> dp(n, vector<int>(n, 0));

    // Initialize last row
    for (int j = 0; j < n; j++) dp[n-1][j] = triangle[n-1][j];

    // Bottom-up DP
    for (int i = n-2; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            int down = triangle[i][j] + dp[i+1][j];
            int diagonal = triangle[i][j] + dp[i+1][j+1];
            dp[i][j] = min(down, diagonal);
        }
    }
    return dp[0][0];
}

int main() {
    vector<vector<int>> triangle{{1}, {2, 3}, {3, 6, 7}, {8, 9, 6, 10}};
    int n = triangle.size();
    cout << "Minimum Path Sum: " << minimumPathSum(triangle, n);
}

Output:
14

â± Complexity:

Time: O(NÂ²)

Space: O(NÂ²)

ğŸŸ¢ Step 4: Space Optimization (1D DP)

Notice we only need the next row to calculate the current row.
So we can optimize space from O(NÂ²) â†’ O(N).

C++ Code:
#include <bits/stdc++.h>
using namespace std;

int minimumPathSum(vector<vector<int>>& triangle, int n) {
    vector<int> front(n, 0), cur(n, 0);

    // Initialize with last row
    for (int j = 0; j < n; j++) front[j] = triangle[n-1][j];

    // Bottom-up with 1D DP
    for (int i = n-2; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            int down = triangle[i][j] + front[j];
            int diagonal = triangle[i][j] + front[j+1];
            cur[j] = min(down, diagonal);
        }
        front = cur;
    }
    return front[0];
}

int main() {
    vector<vector<int>> triangle{{1}, {2, 3}, {3, 6, 7}, {8, 9, 6, 10}};
    int n = triangle.size();
    cout << "Minimum Path Sum: " << minimumPathSum(triangle, n);
}

Output:
14

â± Complexity:

Time: O(NÂ²)

Space: O(N)

âœ… Final Comparison of Approaches
Approach	Time Complexity	Space Complexity
Recursion	O(2^N) âŒ	O(N) (stack)
Memoization	O(NÂ²)	O(NÂ²)
Tabulation	O(NÂ²)	O(NÂ²)
Space Optimized	O(NÂ²) âœ…	O(N) âœ…

ğŸ”¥ Key Takeaways:

Triangular DP problems follow downward movement recursion.

Best solution: Space Optimized DP.

Useful in interview rounds (Leetcode Hard variations exist too).
