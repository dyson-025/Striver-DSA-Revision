ğŸ“˜ Buy and Sell Stock - III (DP-37)
link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/
Problem:
We are given an array Arr[] of stock prices for n days.

We can do at most 2 transactions.

Each transaction = 1 buy + 1 sell.

Canâ€™t sell before buying and canâ€™t buy again without selling first.

Goal: Maximize profit.

ğŸ” Intuition

This is an extension of Buy and Sell Stock II, but now we have a restriction:
â¡ At most 2 transactions allowed.

So, we must carefully track:

Day index (ind)

Whether we can buy or not (buy) â†’ 0 = can buy, 1 = can sell

Transactions left (cap) â†’ from 2 down to 0

That means our state space = [ind][buy][cap].

ğŸ“ Recursive Thinking
Base Cases:

If ind == n â†’ no days left â†’ profit = 0.

If cap == 0 â†’ no transactions left â†’ profit = 0.

Choices:

If we can buy (buy==0):

Skip â†’ f(ind+1,0,cap)

Buy â†’ -Arr[ind] + f(ind+1,1,cap)

If we can sell (buy==1):

Skip â†’ f(ind+1,1,cap)

Sell â†’ +Arr[ind] + f(ind+1,0,cap-1)

Transition:
f(ind,buy,cap) = 
    if buy == 0: max( f(ind+1,0,cap), -Arr[ind] + f(ind+1,1,cap) )
    if buy == 1: max( f(ind+1,1,cap),  Arr[ind] + f(ind+1,0,cap-1) )

ğŸ”„ Memoization (Top-down DP)
int getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp) {
    if (ind == n || cap == 0) return 0;
    if (dp[ind][buy][cap] != -1) return dp[ind][buy][cap];

    int profit = 0;
    if (buy == 0) { 
        profit = max(0 + getAns(Arr, n, ind+1, 0, cap, dp),
                     -Arr[ind] + getAns(Arr, n, ind+1, 1, cap, dp));
    } 
    else { 
        profit = max(0 + getAns(Arr, n, ind+1, 1, cap, dp),
                     Arr[ind] + getAns(Arr, n, ind+1, 0, cap-1, dp));
    }
    return dp[ind][buy][cap] = profit;
}

int maxProfit(vector<int>& prices, int n) {
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));
    return getAns(prices, n, 0, 0, 2, dp);
}


âœ… Time Complexity: O(N*2*3)
âœ… Space Complexity: O(N*2*3 + N) (dp + recursion stack)

ğŸ“‹ Tabulation (Bottom-up DP)
int maxProfit(vector<int>& Arr, int n) {
    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, 0)));

    for (int ind = n-1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= 2; cap++) {
                if (buy == 0) {
                    dp[ind][buy][cap] = max(dp[ind+1][0][cap], 
                                            -Arr[ind] + dp[ind+1][1][cap]);
                } else {
                    dp[ind][buy][cap] = max(dp[ind+1][1][cap], 
                                            Arr[ind] + dp[ind+1][0][cap-1]);
                }
            }
        }
    }
    return dp[0][0][2];
}


âœ… Time Complexity: O(N*2*3)
âœ… Space Complexity: O(N*2*3)

ğŸ’¡ Space Optimization

We only need dp[ind+1] to compute dp[ind].
So we can use 2D arrays (ahead & cur).

int maxProfit(vector<int>& Arr, int n) {
    vector<vector<int>> ahead(2, vector<int>(3, 0)), cur(2, vector<int>(3, 0));

    for (int ind = n-1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= 2; cap++) {
                if (buy == 0)
                    cur[buy][cap] = max(ahead[0][cap], -Arr[ind] + ahead[1][cap]);
                else
                    cur[buy][cap] = max(ahead[1][cap], Arr[ind] + ahead[0][cap-1]);
            }
        }
        ahead = cur;
    }
    return ahead[0][2];
}


âœ… Time Complexity: O(N*2*3)
âœ… Space Complexity: O(2*3) = O(1)

ğŸ¯ Final Notes (Quick Revision)

State â†’ dp[ind][buy][cap]

Cap decreases only when a sell happens (since that completes a transaction).

At most 2 transactions allowed.

3 Approaches:

Memoization â†’ Easy to write, higher memory.

Tabulation â†’ Iterative, memory heavy.

Space Optimization â†’ Best (O(1) space).
