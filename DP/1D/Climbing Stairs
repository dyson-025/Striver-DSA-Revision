ğŸš€ Climbing Stairs â€“ DP Revision Notes
 https://leetcode.com/problems/climbing-stairs/
ğŸ”¹ Problem Statement

You are given n stairs (0 â†’ N).

At each step, you can climb 1 stair or 2 stairs.

Find total distinct ways to reach the Nth stair.

ğŸ”¹ How to Identify DP Problem?

Count total number of ways â†’ Strong hint for DP.

Can be solved via choices at each step.

Overlapping subproblems (f(n) depends on f(n-1) & f(n-2)).

ğŸ”¹ Steps to Solve

Represent problem in terms of index (n).

Choices:

Jump 1 step â†’ f(n-1)

Jump 2 steps â†’ f(n-2)

Since question asks count of ways â†’ take sum.

ğŸ‘‰ Recurrence Relation:

ğ‘“
(
ğ‘›
)
=
ğ‘“
(
ğ‘›
âˆ’
1
)
+
ğ‘“
(
ğ‘›
âˆ’
2
)
f(n)=f(nâˆ’1)+f(nâˆ’2)

Base Cases:

f(0) = 1 (1 way: stay at ground).

f(1) = 1 (1 way: single jump).

âš ï¸ Edge case: Donâ€™t allow f(-1) â†’ handled by base case.

ğŸ”¹ Recursive Approach

Exponential time (re-computation).

Equivalent to Fibonacci recursion.

ğŸ”¹ DP Approaches
1ï¸âƒ£ Tabulation (Bottom-Up DP)

Use dp[] array.

Transition: dp[i] = dp[i-1] + dp[i-2].

Code (C++):

int climbStairs(int n) {
    vector<int> dp(n+1, 0);
    dp[0] = dp[1] = 1;
    for(int i=2; i<=n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}


â± Time: O(N)
ğŸ“¦ Space: O(N)

2ï¸âƒ£ Space Optimized DP

Only last two values are needed.

Use variables prev and prev2.

Code (C++):

int climbStairs(int n) {
    int prev2 = 1, prev = 1;
    for(int i=2; i<=n; i++){
        int cur = prev + prev2;
        prev2 = prev;
        prev = cur;
    }
    return prev;
}


â± Time: O(N)
ğŸ“¦ Space: O(1)

ğŸ”¹ Key Takeaways

Problem is identical to Fibonacci sequence shifted by index.

Always check base cases (n=0, n=1) carefully.

For large n, always use DP / Space Optimized version.

âœ… Final Formula:
f(n)=f(nâˆ’1)+f(nâˆ’2),f(0)=1,f(1)=1

ğŸªœ Climbing Stairs DP â€“ Flowchart
Start â†’ Input n
      |
      v
Is n = 0 or n = 1? â”€â”€Yesâ”€â”€> return 1
      |
      No
      |
      v
Initialize:
  prev2 = 1   (f(0))
  prev  = 1   (f(1))
      |
      v
For i = 2 to n:
      |
      v
    cur = prev + prev2   // f(i) = f(i-1) + f(i-2)
      |
      v
    prev2 = prev
    prev  = cur
      |
      v
Loop ends â†’ return prev
      |
      v
End

ğŸ”¹ Flow Explanation

Check Base Cases:

n=0 â†’ 1 way

n=1 â†’ 1 way

Initialize DP variables:

prev2 = f(0)

prev = f(1)

Iterate from 2 to n:

cur = prev + prev2 (sum of last two ways)

Update prev2 & prev for next iteration

Return final answer (prev)

âœ… This is exactly the space-optimized approach, visually easy to memorize.
