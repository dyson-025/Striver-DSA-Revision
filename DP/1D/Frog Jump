ğŸ¸ Frog Jump â€“ DP Revision Notes
 link: https://www.geeksforgeeks.org/problems/geek-jump/1
ğŸ”¹ Problem Statement

Frog wants to jump from stair 0 â†’ stair N-1.

Can jump 1 step or 2 steps at a time.

height[N] array is given.

Energy cost for a jump: abs(height[i] - height[j]).

Goal: Minimize total energy to reach stair N-1.

ğŸ”¹ Why Not Greedy?

Choosing the locally minimum jump may lead to higher total energy later.

Must consider all possible paths â†’ DP is needed.

ğŸ”¹ Recursive Approach

Steps:

Express problem in terms of indexes: f(i) = min energy to reach stair i.

Choices:

Jump 1 step: f(i-1) + abs(height[i]-height[i-1])

Jump 2 steps: f(i-2) + abs(height[i]-height[i-2]) (if i>1)

Return minimum of the two choices.

Base Case:

f(0) = 0

âœ… Memoization (Top-Down DP)

Store results in dp[] array to avoid recomputation.

C++ Code:

int solve(int ind, vector<int>& height, vector<int>& dp){
    if(ind==0) return 0;
    if(dp[ind]!=-1) return dp[ind];

    int jumpOne = solve(ind-1,height,dp) + abs(height[ind]-height[ind-1]);
    int jumpTwo = INT_MAX;
    if(ind>1) 
        jumpTwo = solve(ind-2,height,dp) + abs(height[ind]-height[ind-2]);

    return dp[ind] = min(jumpOne, jumpTwo);
}


â± Time: O(N)
ğŸ“¦ Space: O(N) (recursion stack + dp array)

âœ… Tabulation (Bottom-Up DP)

Iteratively fill dp[] from 0 â†’ N-1.

C++ Code:

dp[0] = 0;
for(int i=1; i<n; i++){
    int jumpOne = dp[i-1] + abs(height[i]-height[i-1]);
    int jumpTwo = (i>1) ? dp[i-2] + abs(height[i]-height[i-2]) : INT_MAX;
    dp[i] = min(jumpOne, jumpTwo);
}


â± Time: O(N)
ğŸ“¦ Space: O(N)

âœ… Space Optimized DP

Only prev and prev2 values are needed at each step.

C++ Code:

int prev = 0, prev2 = 0;
for(int i=1; i<n; i++){
    int jumpOne = prev + abs(height[i]-height[i-1]);
    int jumpTwo = (i>1) ? prev2 + abs(height[i]-height[i-2]) : INT_MAX;
    int cur = min(jumpOne, jumpTwo);
    prev2 = prev;
    prev = cur;
}
cout << prev;


â± Time: O(N)
ğŸ“¦ Space: O(1)

ğŸ”¹ Key Takeaways

Problem is like Climbing Stairs, but now with cost/energy.

Always check base cases: i=0 and i=1.

Greedy fails, must explore all paths â†’ DP.

Space optimization works by tracking only last 2 states.

âœ… Recurrence Relation:

f(i)=min(f(iâˆ’1)+âˆ£h[i]âˆ’h[iâˆ’1]âˆ£,Â f(iâˆ’2)+âˆ£h[i]âˆ’h[iâˆ’2]âˆ£)
f(0)=0

Perfect! Hereâ€™s a flowchart for the Frog Jump DP problemâ€”easy to memorize and perfect for revision.

ğŸ¸ Frog Jump â€“ Flowchart (Space Optimized DP)
Start â†’ Input n, height[]
      |
      v
Is n = 0? â”€â”€Yesâ”€â”€> return 0
      |
      No
      |
      v
Initialize:
  prev2 = 0   // f(0)
  prev  = 0   // will calculate for i=1
      |
      v
For i = 1 to n-1:
      |
      v
  jumpOne = prev + abs(height[i]-height[i-1])
  jumpTwo = (i>1) ? prev2 + abs(height[i]-height[i-2]) : INF
  cur = min(jumpOne, jumpTwo)
  prev2 = prev
  prev = cur
      |
      v
Loop ends â†’ return prev
      |
      v
End

ğŸ”¹ Flow Explanation

Base Case:

If n=0, energy = 0.

Initialize Variables:

prev2 = f(0) = 0

prev = f(1) will be calculated in the first iteration.

Iterate from i = 1 to n-1:

jumpOne = jump from previous stair

jumpTwo = jump from two stairs behind (if i>1)

cur = min(jumpOne, jumpTwo) â†’ minimum energy for current stair

Update prev2 & prev for next iteration

Return final answer â†’ prev
