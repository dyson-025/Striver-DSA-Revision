🧠 Dynamic Programming – Longest Increasing Subsequence (LIS)
link: https://leetcode.com/problems/longest-increasing-subsequence/
link: https://www.geeksforgeeks.org/problems/printing-longest-increasing-subsequence/1
Topics Covered:

Concept of Subsequence and LIS

Recursive Approach

Memoization (Top-Down DP)

Tabulation (Bottom-Up DP)

Space Optimization

Tabulation Algorithm (O(N²))

Printing the LIS Sequence

Binary Search Approach (O(N log N))

Time and Space Complexities

🔹 1. What is a Subsequence?

A subsequence is a sequence derived from another sequence by deleting some (or none) of its elements without changing the order of the remaining elements.

👉 Example:
For arr = [2, 3, 1]
Possible subsequences:
[2], [3], [1], [2,3], [2,1], [3,1], [2,3,1]

❌ [3,2] is not a subsequence (order changed).

🔹 2. What is the Longest Increasing Subsequence (LIS)?

A Longest Increasing Subsequence is the subsequence of maximum possible length such that all elements are strictly increasing.

👉 Example:
arr = [10, 9, 2, 5, 3, 7, 101, 18]
LIS = [2, 3, 7, 101]
Answer = 4

🔹 3. Approach 1 – Recursive (Brute Force)
🧩 Intuition:

At each index ind, we have two choices:

Take arr[ind] in our subsequence (if it’s greater than the last taken element).

Not take it.

We keep exploring both paths recursively.

🧠 Recurrence Definition:
f(ind, prev_index):
    if ind == n: return 0
    
    notTake = f(ind+1, prev_index)
    take = 0
    if prev_index == -1 or arr[ind] > arr[prev_index]:
        take = 1 + f(ind+1, ind)

    return max(take, notTake)

🧮 Base Case:

If ind == n, no more elements left → return 0.

⏱️ Time Complexity:

O(2^N) – exponential due to all subsequences.

🔹 4. Approach 2 – Memoization (Top-Down DP)

We see overlapping subproblems → memoize using a 2D DP array.

🧠 State:

dp[ind][prev_index+1] → stores LIS length from ind with previous index prev_index.

We use +1 shift to handle -1 (no previous element).

💻 Code:
int getAns(int arr[], int n, int ind, int prev_index, vector<vector<int>>& dp) {
    if (ind == n) return 0;
    if (dp[ind][prev_index+1] != -1) return dp[ind][prev_index+1];

    int notTake = getAns(arr, n, ind+1, prev_index, dp);
    int take = 0;
    if (prev_index == -1 || arr[ind] > arr[prev_index])
        take = 1 + getAns(arr, n, ind+1, ind, dp);

    return dp[ind][prev_index+1] = max(take, notTake);
}

int LIS(int arr[], int n) {
    vector<vector<int>> dp(n, vector<int>(n+1, -1));
    return getAns(arr, n, 0, -1, dp);
}

⏱️ Time Complexity:

O(N²) → N * N possible states

🧮 Space Complexity:

O(N²) + O(N) (dp + recursion stack)

🔹 5. Approach 3 – Tabulation (Bottom-Up DP)

We’ll create a 2D dp table as dp[n+1][n+1], iterating from end to start.

💻 Code:
int LIS(int arr[], int n) {
    vector<vector<int>> dp(n+1, vector<int>(n+1, 0));

    for (int ind = n-1; ind >= 0; ind--) {
        for (int prev = ind-1; prev >= -1; prev--) {
            int notTake = dp[ind+1][prev+1];
            int take = 0;
            if (prev == -1 || arr[ind] > arr[prev])
                take = 1 + dp[ind+1][ind+1];
            dp[ind][prev+1] = max(take, notTake);
        }
    }
    return dp[0][0];
}

⏱️ Time: O(N²)
🧮 Space: O(N²)
🔹 6. Space Optimization (2 Rows Only)

We only need dp[ind+1] to compute dp[ind].

💻 Code:
int LIS(int arr[], int n) {
    vector<int> next(n+1, 0), cur(n+1, 0);

    for (int ind = n-1; ind >= 0; ind--) {
        for (int prev = ind-1; prev >= -1; prev--) {
            int notTake = next[prev+1];
            int take = 0;
            if (prev == -1 || arr[ind] > arr[prev])
                take = 1 + next[ind+1];
            cur[prev+1] = max(take, notTake);
        }
        next = cur;
    }
    return cur[0];
}

⏱️ Time: O(N²)
🧮 Space: O(N)
🔹 7. Approach 4 – Tabulation Algorithm (1D DP)

Here we define:
dp[i] = length of LIS ending at index i

💡 Idea:

For every index i, check all previous indices j < i.
If arr[j] < arr[i], we can extend the LIS ending at j to include i.

So:
dp[i] = max(dp[i], 1 + dp[j])

💻 Code:
int LIS(int arr[], int n) {
    vector<int> dp(n, 1);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i])
                dp[i] = max(dp[i], 1 + dp[j]);
        }
    }

    return *max_element(dp.begin(), dp.end());
}

⏱️ Time: O(N²)
🧮 Space: O(N)
🔹 8. Printing the Actual LIS

We use a hash array to trace back predecessors.

💻 Code:
int LIS_Print(int arr[], int n) {
    vector<int> dp(n, 1), hash(n);

    int ans = 1, lastIndex = 0;
    for (int i = 0; i < n; i++) {
        hash[i] = i;
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
                dp[i] = 1 + dp[j];
                hash[i] = j;
            }
        }
        if (dp[i] > ans) {
            ans = dp[i];
            lastIndex = i;
        }
    }

    // Reconstruct sequence
    vector<int> lis;
    lis.push_back(arr[lastIndex]);
    while (hash[lastIndex] != lastIndex) {
        lastIndex = hash[lastIndex];
        lis.push_back(arr[lastIndex]);
    }
    reverse(lis.begin(), lis.end());

    cout << "LIS sequence: ";
    for (int x : lis) cout << x << " ";
    cout << endl;

    return ans;
}

Example Output:
LIS sequence: 2 5 7 101

🔹 9. Approach 5 – Binary Search Optimization (O(N log N))
🧠 Core Idea:

We maintain a temporary array (temp) such that:

It is always sorted.

Its length = length of LIS so far.

For each element arr[i]:

If arr[i] > temp.back(), append it.

Else, find index of the smallest element >= arr[i] using lower_bound() and replace it.

💻 Code:
int LIS_BinarySearch(int arr[], int n) {
    vector<int> temp;
    temp.push_back(arr[0]);
    int len = 1;

    for (int i = 1; i < n; i++) {
        if (arr[i] > temp.back()) {
            temp.push_back(arr[i]);
            len++;
        } else {
            int ind = lower_bound(temp.begin(), temp.end(), arr[i]) - temp.begin();
            temp[ind] = arr[i];
        }
    }
    return len;
}

Example:

arr = [10,9,2,5,3,7,101,18]
temp changes as follows:

[10]
[9]
[2]
[2,5]
[2,3]
[2,3,7]
[2,3,7,101]
[2,3,7,18]


Final Length = 4

⚙️ Complexity Analysis:
Approach	Time Complexity	Space Complexity
Recursion	O(2ⁿ)	O(N)
Memoization	O(N²)	O(N²)
Tabulation	O(N²)	O(N²)
Space Optimized	O(N²)	O(N)
Tabulation 1D (dp[i])	O(N²)	O(N)
Printing LIS	O(N²)	O(N)
Binary Search	O(N log N)	O(N)
💬 Key Takeaways

LIS is a classic DP problem that helps understand subsequences.

dp[i] approach (O(N²)) is most intuitive.

Binary Search approach is the most efficient (O(N log N)).

To print LIS, store backtracking information using a hash array.

The binary search version only gives length, not sequence (unless modified).

✅ Final Quick Reference
Version	Use Case	Pros	Cons
Recursion	Learning base concept	Simple	Exponential
Memoization	Intro to DP	Structured	Space heavy
Tabulation	Efficient	Bottom-up logic	Slightly complex
Tabulation 1D	Practical for interviews	Simple and efficient	Still O(N²)
Binary Search	Competitive programming	Fastest O(N log N)	Harder to modify for printing
