ğŸ§  Dynamic Programming â€“ Longest Increasing Subsequence (LIS)
link: https://leetcode.com/problems/longest-increasing-subsequence/
link: https://www.geeksforgeeks.org/problems/printing-longest-increasing-subsequence/1
Topics Covered:

Concept of Subsequence and LIS

Recursive Approach

Memoization (Top-Down DP)

Tabulation (Bottom-Up DP)

Space Optimization

Tabulation Algorithm (O(NÂ²))

Printing the LIS Sequence

Binary Search Approach (O(N log N))

Time and Space Complexities

ğŸ”¹ 1. What is a Subsequence?

A subsequence is a sequence derived from another sequence by deleting some (or none) of its elements without changing the order of the remaining elements.

ğŸ‘‰ Example:
For arr = [2, 3, 1]
Possible subsequences:
[2], [3], [1], [2,3], [2,1], [3,1], [2,3,1]

âŒ [3,2] is not a subsequence (order changed).

ğŸ”¹ 2. What is the Longest Increasing Subsequence (LIS)?

A Longest Increasing Subsequence is the subsequence of maximum possible length such that all elements are strictly increasing.

ğŸ‘‰ Example:
arr = [10, 9, 2, 5, 3, 7, 101, 18]
LIS = [2, 3, 7, 101]
Answer = 4

ğŸ”¹ 3. Approach 1 â€“ Recursive (Brute Force)
ğŸ§© Intuition:

At each index ind, we have two choices:

Take arr[ind] in our subsequence (if itâ€™s greater than the last taken element).

Not take it.

We keep exploring both paths recursively.

ğŸ§  Recurrence Definition:
f(ind, prev_index):
    if ind == n: return 0
    
    notTake = f(ind+1, prev_index)
    take = 0
    if prev_index == -1 or arr[ind] > arr[prev_index]:
        take = 1 + f(ind+1, ind)

    return max(take, notTake)

ğŸ§® Base Case:

If ind == n, no more elements left â†’ return 0.

â±ï¸ Time Complexity:

O(2^N) â€“ exponential due to all subsequences.

ğŸ”¹ 4. Approach 2 â€“ Memoization (Top-Down DP)

We see overlapping subproblems â†’ memoize using a 2D DP array.

ğŸ§  State:

dp[ind][prev_index+1] â†’ stores LIS length from ind with previous index prev_index.

We use +1 shift to handle -1 (no previous element).

ğŸ’» Code:
int getAns(int arr[], int n, int ind, int prev_index, vector<vector<int>>& dp) {
    if (ind == n) return 0;
    if (dp[ind][prev_index+1] != -1) return dp[ind][prev_index+1];

    int notTake = getAns(arr, n, ind+1, prev_index, dp);
    int take = 0;
    if (prev_index == -1 || arr[ind] > arr[prev_index])
        take = 1 + getAns(arr, n, ind+1, ind, dp);

    return dp[ind][prev_index+1] = max(take, notTake);
}

int LIS(int arr[], int n) {
    vector<vector<int>> dp(n, vector<int>(n+1, -1));
    return getAns(arr, n, 0, -1, dp);
}

â±ï¸ Time Complexity:

O(NÂ²) â†’ N * N possible states

ğŸ§® Space Complexity:

O(NÂ²) + O(N) (dp + recursion stack)

ğŸ”¹ 5. Approach 3 â€“ Tabulation (Bottom-Up DP)

Weâ€™ll create a 2D dp table as dp[n+1][n+1], iterating from end to start.

ğŸ’» Code:
int LIS(int arr[], int n) {
    vector<vector<int>> dp(n+1, vector<int>(n+1, 0));

    for (int ind = n-1; ind >= 0; ind--) {
        for (int prev = ind-1; prev >= -1; prev--) {
            int notTake = dp[ind+1][prev+1];
            int take = 0;
            if (prev == -1 || arr[ind] > arr[prev])
                take = 1 + dp[ind+1][ind+1];
            dp[ind][prev+1] = max(take, notTake);
        }
    }
    return dp[0][0];
}

â±ï¸ Time: O(NÂ²)
ğŸ§® Space: O(NÂ²)
ğŸ”¹ 6. Space Optimization (2 Rows Only)

We only need dp[ind+1] to compute dp[ind].

ğŸ’» Code:
int LIS(int arr[], int n) {
    vector<int> next(n+1, 0), cur(n+1, 0);

    for (int ind = n-1; ind >= 0; ind--) {
        for (int prev = ind-1; prev >= -1; prev--) {
            int notTake = next[prev+1];
            int take = 0;
            if (prev == -1 || arr[ind] > arr[prev])
                take = 1 + next[ind+1];
            cur[prev+1] = max(take, notTake);
        }
        next = cur;
    }
    return cur[0];
}

â±ï¸ Time: O(NÂ²)
ğŸ§® Space: O(N)
ğŸ”¹ 7. Approach 4 â€“ Tabulation Algorithm (1D DP)

Here we define:
dp[i] = length of LIS ending at index i

ğŸ’¡ Idea:

For every index i, check all previous indices j < i.
If arr[j] < arr[i], we can extend the LIS ending at j to include i.

So:
dp[i] = max(dp[i], 1 + dp[j])

ğŸ’» Code:
int LIS(int arr[], int n) {
    vector<int> dp(n, 1);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i])
                dp[i] = max(dp[i], 1 + dp[j]);
        }
    }

    return *max_element(dp.begin(), dp.end());
}

â±ï¸ Time: O(NÂ²)
ğŸ§® Space: O(N)
ğŸ”¹ 8. Printing the Actual LIS

We use a hash array to trace back predecessors.

ğŸ’» Code:
int LIS_Print(int arr[], int n) {
    vector<int> dp(n, 1), hash(n);

    int ans = 1, lastIndex = 0;
    for (int i = 0; i < n; i++) {
        hash[i] = i;
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
                dp[i] = 1 + dp[j];
                hash[i] = j;
            }
        }
        if (dp[i] > ans) {
            ans = dp[i];
            lastIndex = i;
        }
    }

    // Reconstruct sequence
    vector<int> lis;
    lis.push_back(arr[lastIndex]);
    while (hash[lastIndex] != lastIndex) {
        lastIndex = hash[lastIndex];
        lis.push_back(arr[lastIndex]);
    }
    reverse(lis.begin(), lis.end());

    cout << "LIS sequence: ";
    for (int x : lis) cout << x << " ";
    cout << endl;

    return ans;
}

Example Output:
LIS sequence: 2 5 7 101

ğŸ”¹ 9. Approach 5 â€“ Binary Search Optimization (O(N log N))
ğŸ§  Core Idea:

We maintain a temporary array (temp) such that:

It is always sorted.

Its length = length of LIS so far.

For each element arr[i]:

If arr[i] > temp.back(), append it.

Else, find index of the smallest element >= arr[i] using lower_bound() and replace it.

ğŸ’» Code:
int LIS_BinarySearch(int arr[], int n) {
    vector<int> temp;
    temp.push_back(arr[0]);
    int len = 1;

    for (int i = 1; i < n; i++) {
        if (arr[i] > temp.back()) {
            temp.push_back(arr[i]);
            len++;
        } else {
            int ind = lower_bound(temp.begin(), temp.end(), arr[i]) - temp.begin();
            temp[ind] = arr[i];
        }
    }
    return len;
}

Example:

arr = [10,9,2,5,3,7,101,18]
temp changes as follows:

[10]
[9]
[2]
[2,5]
[2,3]
[2,3,7]
[2,3,7,101]
[2,3,7,18]


Final Length = 4

âš™ï¸ Complexity Analysis:
Approach	Time Complexity	Space Complexity
Recursion	O(2â¿)	O(N)
Memoization	O(NÂ²)	O(NÂ²)
Tabulation	O(NÂ²)	O(NÂ²)
Space Optimized	O(NÂ²)	O(N)
Tabulation 1D (dp[i])	O(NÂ²)	O(N)
Printing LIS	O(NÂ²)	O(N)
Binary Search	O(N log N)	O(N)
ğŸ’¬ Key Takeaways

LIS is a classic DP problem that helps understand subsequences.

dp[i] approach (O(NÂ²)) is most intuitive.

Binary Search approach is the most efficient (O(N log N)).

To print LIS, store backtracking information using a hash array.

The binary search version only gives length, not sequence (unless modified).

âœ… Final Quick Reference
Version	Use Case	Pros	Cons
Recursion	Learning base concept	Simple	Exponential
Memoization	Intro to DP	Structured	Space heavy
Tabulation	Efficient	Bottom-up logic	Slightly complex
Tabulation 1D	Practical for interviews	Simple and efficient	Still O(NÂ²)
Binary Search	Competitive programming	Fastest O(N log N)	Harder to modify for printing
