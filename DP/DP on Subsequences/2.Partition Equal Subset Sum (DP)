2.Partition Equal Subset Sum (DP)
link: https://leetcode.com/problems/partition-equal-subset-sum/description/
Problem Statement

Given an array ARR of N positive integers, determine if it can be partitioned into two subsets with equal sums.

Return: true if possible, else false.

1. Key Observation

Let the total sum of the array be S:

To partition into two equal subsets: S1 + S2 = S and S1 = S2

This implies S1 = S2 = S / 2

If S is odd, partitioning is impossible → return false.

If S is even, problem reduces to Subset Sum problem:
Check if there is a subset with sum = S/2.

2. Recursive Approach (Pick / Non-Pick)
Step 1: Define Problem

f(ind, target) → whether a subset exists in ARR[0..ind] with sum = target

Initially call f(n-1, S/2)

Step 2: Base Cases

target == 0 → subset found → return true

ind == 0 → check if ARR[0] == target

Step 3: Choices at Index ind

Not Take: f(ind-1, target)

Take (if arr[ind] <= target): f(ind-1, target-arr[ind])

Return: taken || notTaken

Recursive Code (C++)
bool subsetSumUtil(int ind, int target, vector<int>& arr) {
    if(target == 0) return true;
    if(ind == 0) return arr[0] == target;

    bool notTaken = subsetSumUtil(ind - 1, target, arr);
    bool taken = false;
    if(arr[ind] <= target)
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr);

    return notTaken || taken;
}

bool canPartition(int n, vector<int>& arr) {
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    if(totSum % 2 != 0) return false;

    return subsetSumUtil(n-1, totSum/2, arr);
}


Time Complexity: O(2^N)
Space Complexity: O(N) recursion stack

3. Memoization (Top-Down DP)
Idea

Overlapping subproblems → use DP array dp[ind][target]

Store -1 for uncomputed states

Implementation
bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
    if(target == 0) return true;
    if(ind == 0) return arr[0] == target;
    if(dp[ind][target] != -1) return dp[ind][target];

    bool notTaken = subsetSumUtil(ind-1, target, arr, dp);
    bool taken = false;
    if(arr[ind] <= target)
        taken = subsetSumUtil(ind-1, target-arr[ind], arr, dp);

    return dp[ind][target] = notTaken || taken;
}

bool canPartition(int n, vector<int>& arr) {
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    if(totSum % 2 != 0) return false;

    int k = totSum / 2;
    vector<vector<int>> dp(n, vector<int>(k+1, -1));
    return subsetSumUtil(n-1, k, arr, dp);
}


Complexity Analysis

Time: O(N*K)

Space: O(N*K) + O(N) recursion stack

4. Tabulation (Bottom-Up DP)
Idea

dp[i][t] = true if subset exists in ARR[0..i] with sum = t

Base Cases:

dp[i][0] = true → sum 0 always possible

dp[0][arr[0]] = true → first element can form sum = arr[0]

Transition
dp[ind][target] = dp[ind-1][target] || 
                  (arr[ind] <= target ? dp[ind-1][target-arr[ind]] : false);

Code
bool canPartition(int n, vector<int>& arr) {
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    if(totSum % 2 != 0) return false;

    int k = totSum / 2;
    vector<vector<bool>> dp(n, vector<bool>(k+1, false));

    for(int i=0;i<n;i++) dp[i][0] = true;
    if(arr[0] <= k) dp[0][arr[0]] = true;

    for(int ind=1; ind<n; ind++){
        for(int target=1; target<=k; target++){
            bool notTaken = dp[ind-1][target];
            bool taken = (arr[ind] <= target) ? dp[ind-1][target-arr[ind]] : false;
            dp[ind][target] = notTaken || taken;
        }
    }
    return dp[n-1][k];
}


Time Complexity: O(NK)
Space Complexity: O(NK)

5. Space Optimization
Observation

Only previous row is required → use single array

Code
bool canPartition(int n, vector<int>& arr) {
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    if(totSum % 2 != 0) return false;

    int k = totSum / 2;
    vector<bool> prev(k+1, false);
    prev[0] = true;
    if(arr[0] <= k) prev[arr[0]] = true;

    for(int ind=1; ind<n; ind++){
        vector<bool> cur(k+1, false);
        cur[0] = true;
        for(int target=1; target<=k; target++){
            bool notTaken = prev[target];
            bool taken = (arr[ind] <= target) ? prev[target-arr[ind]] : false;
            cur[target] = notTaken || taken;
        }
        prev = cur;
    }
    return prev[k];
}


Time Complexity: O(N*K)
Space Complexity: O(K)

6. Key Points

Partition problem = Subset Sum problem with target = totalSum / 2

Base Cases:

Target 0 → true

Index 0 → check arr[0] == target

DP Approaches: Recursion → Memoization → Tabulation → Space Optimization

Always check sum parity first: odd sum → impossible
