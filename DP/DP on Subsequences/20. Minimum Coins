🪙 Minimum Coins (DP – 20) — Ultimate Detailed Notes
 link: https://leetcode.com/problems/coin-change/
🔹 Problem Statement

We are given:

A target sum X

An array of N distinct coin denominations arr[]

👉 Task: Find the minimum number of coins required to make the sum X.

You can pick any coin unlimited times (unbounded supply).

If not possible → return -1.

🔹 Why Greedy Fails?

Greedy = pick the largest coin first.

⚠️ Doesn’t always work → local choice ≠ global best.

Example:

Coins = [9, 6, 5, 1], Target = 11

Greedy → 9 + 1 + 1 = 3 coins ❌

Optimal → 6 + 5 = 2 coins ✅

👉 So, we need DP to explore all possibilities.

🔹 Step 1: Recursive Solution (Exponential)
✅ State Definition

Let:
f(ind, T) = minimum coins to form target T using coins 0…ind.

✅ Base Cases

If T == 0 → return 0 (no coins needed).

If ind == 0:

If T % arr[0] == 0 → return T / arr[0].

Else → return ∞ (1e9) (impossible).

✅ Transition (Choice)

At each index ind:

Not Pick → don’t use coin arr[ind]
→ f(ind-1, T)

Pick (if arr[ind] <= T) → use arr[ind]
→ 1 + f(ind, T - arr[ind]) (stay on same ind because unlimited supply)

Formula:

f(ind, T) = min(
   f(ind-1, T),               // not pick
   1 + f(ind, T - arr[ind])   // pick
)

📌 Recursive Code (C++)
#include <bits/stdc++.h>
using namespace std;

int f(int ind, int T, vector<int>& arr) {
    if (T == 0) return 0;
    if (ind == 0) {
        if (T % arr[0] == 0) return T / arr[0];
        else return 1e9;
    }
    int notPick = f(ind-1, T, arr);
    int pick = 1e9;
    if (arr[ind] <= T) pick = 1 + f(ind, T - arr[ind], arr);
    return min(pick, notPick);
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    int n = arr.size();
    int ans = f(n-1, T, arr);
    if (ans >= 1e9) cout << -1;
    else cout << ans;
}


✅ Output: 3 (e.g. 3+2+2).

⚠️ Complexity:

Time: O(2^N) (exponential → TLE for large inputs).

Space: O(N) recursion stack.

🔹 Step 2: Memoization (Top-Down DP)

To avoid recomputation, use a dp[n][T+1] table.

📌 Memoization Code (C++)
#include <bits/stdc++.h>
using namespace std;

int f(int ind, int T, vector<int>& arr, vector<vector<int>>& dp) {
    if (T == 0) return 0;
    if (ind == 0) {
        if (T % arr[0] == 0) return T / arr[0];
        else return 1e9;
    }
    if (dp[ind][T] != -1) return dp[ind][T];

    int notPick = f(ind-1, T, arr, dp);
    int pick = 1e9;
    if (arr[ind] <= T) pick = 1 + f(ind, T - arr[ind], arr, dp);

    return dp[ind][T] = min(pick, notPick);
}

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(T+1, -1));
    int ans = f(n-1, T, arr, dp);
    return (ans >= 1e9) ? -1 : ans;
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


✅ Complexity:

Time: O(N*T)

Space: O(N*T) + O(N) (DP table + recursion).

🔹 Step 3: Tabulation (Bottom-Up DP)

We build iteratively instead of recursion.

📌 Tabulation Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(T+1, 0));

    // Base case
    for (int t = 0; t <= T; t++) {
        if (t % arr[0] == 0) dp[0][t] = t / arr[0];
        else dp[0][t] = 1e9;
    }

    // Fill table
    for (int i = 1; i < n; i++) {
        for (int t = 0; t <= T; t++) {
            int notTake = dp[i-1][t];
            int take = 1e9;
            if (arr[i] <= t) take = 1 + dp[i][t - arr[i]];
            dp[i][t] = min(notTake, take);
        }
    }

    int ans = dp[n-1][T];
    return (ans >= 1e9) ? -1 : ans;
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


✅ Complexity:

Time: O(N*T)

Space: O(N*T)

🔹 Step 4: Space Optimized Tabulation

We only need current row + previous row.
Even further, since “pick” uses current row (dp[target - arr[i]]), we can reduce to a 1D array.

📌 Space-Optimized Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<int> dp(T+1, 1e9);

    // Base case
    for (int t = 0; t <= T; t++) {
        if (t % arr[0] == 0) dp[t] = t / arr[0];
    }

    // Build dp
    for (int i = 1; i < n; i++) {
        for (int t = 0; t <= T; t++) {
            int notTake = dp[t];
            int take = 1e9;
            if (arr[i] <= t) take = 1 + dp[t - arr[i]];
            dp[t] = min(notTake, take);
        }
    }

    return (dp[T] >= 1e9) ? -1 : dp[T];
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


✅ Complexity:

Time: O(N*T)

Space: O(T)

🔹 Dry Run Example

Input: arr = {1, 2, 3}, T = 7

Table filling (tabulation):

dp[0][t] = t (since only coin=1 works)

Row for coin=2:

dp[1][7] = min(dp[0][7]=7, 1+dp[1][5]=1+3=4) = 4

Row for coin=3:

dp[2][7] = min(dp[1][7]=4, 1+dp[2][4]=1+2=3) = 3 ✅

Answer = 3 (e.g. 3+2+2).

🔹 Edge Cases

X = 0 → return 0 (no coins needed).

If no valid combo exists → return -1.

If arr doesn’t contain 1, some targets may be impossible.

Large inputs → must use DP, recursion will TLE.

🔹 Complexity Summary
Approach	Time	Space	Notes
Recursion	Exponential	O(N)	TLE
Memoization	O(N*T)	O(N*T)+O(N)	Top-down
Tabulation	O(N*T)	O(N*T)	Bottom-up
Space Optimized	O(N*T)	O(T)	Best
🔹 Relation to Patterns

This is a classic Unbounded Knapsack problem.

Each coin = item

Weight = coin value

Can use unlimited times

Instead of maximizing value, we minimize the count.

Similar Problems:

Coin Change I (min coins)

Coin Change II (count ways)

Rod Cutting

Unbounded Knapsack

🔹 Final Takeaways

Don’t use greedy → fails in non-uniform coins.

Start with recursion → add memoization → tabulation → optimize space.

Base case (when ind==0): if divisible → return quotient else ∞.

Final answer: dp[n-1][T], return -1 if ≥ 1e9.
