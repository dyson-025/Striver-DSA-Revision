ğŸª™ Minimum Coins (DP â€“ 20) â€” Ultimate Detailed Notes
 link: https://leetcode.com/problems/coin-change/
ğŸ”¹ Problem Statement

We are given:

A target sum X

An array of N distinct coin denominations arr[]

ğŸ‘‰ Task: Find the minimum number of coins required to make the sum X.

You can pick any coin unlimited times (unbounded supply).

If not possible â†’ return -1.

ğŸ”¹ Why Greedy Fails?

Greedy = pick the largest coin first.

âš ï¸ Doesnâ€™t always work â†’ local choice â‰  global best.

Example:

Coins = [9, 6, 5, 1], Target = 11

Greedy â†’ 9 + 1 + 1 = 3 coins âŒ

Optimal â†’ 6 + 5 = 2 coins âœ…

ğŸ‘‰ So, we need DP to explore all possibilities.

ğŸ”¹ Step 1: Recursive Solution (Exponential)
âœ… State Definition

Let:
f(ind, T) = minimum coins to form target T using coins 0â€¦ind.

âœ… Base Cases

If T == 0 â†’ return 0 (no coins needed).

If ind == 0:

If T % arr[0] == 0 â†’ return T / arr[0].

Else â†’ return âˆ (1e9) (impossible).

âœ… Transition (Choice)

At each index ind:

Not Pick â†’ donâ€™t use coin arr[ind]
â†’ f(ind-1, T)

Pick (if arr[ind] <= T) â†’ use arr[ind]
â†’ 1 + f(ind, T - arr[ind]) (stay on same ind because unlimited supply)

Formula:

f(ind, T) = min(
   f(ind-1, T),               // not pick
   1 + f(ind, T - arr[ind])   // pick
)

ğŸ“Œ Recursive Code (C++)
#include <bits/stdc++.h>
using namespace std;

int f(int ind, int T, vector<int>& arr) {
    if (T == 0) return 0;
    if (ind == 0) {
        if (T % arr[0] == 0) return T / arr[0];
        else return 1e9;
    }
    int notPick = f(ind-1, T, arr);
    int pick = 1e9;
    if (arr[ind] <= T) pick = 1 + f(ind, T - arr[ind], arr);
    return min(pick, notPick);
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    int n = arr.size();
    int ans = f(n-1, T, arr);
    if (ans >= 1e9) cout << -1;
    else cout << ans;
}


âœ… Output: 3 (e.g. 3+2+2).

âš ï¸ Complexity:

Time: O(2^N) (exponential â†’ TLE for large inputs).

Space: O(N) recursion stack.

ğŸ”¹ Step 2: Memoization (Top-Down DP)

To avoid recomputation, use a dp[n][T+1] table.

ğŸ“Œ Memoization Code (C++)
#include <bits/stdc++.h>
using namespace std;

int f(int ind, int T, vector<int>& arr, vector<vector<int>>& dp) {
    if (T == 0) return 0;
    if (ind == 0) {
        if (T % arr[0] == 0) return T / arr[0];
        else return 1e9;
    }
    if (dp[ind][T] != -1) return dp[ind][T];

    int notPick = f(ind-1, T, arr, dp);
    int pick = 1e9;
    if (arr[ind] <= T) pick = 1 + f(ind, T - arr[ind], arr, dp);

    return dp[ind][T] = min(pick, notPick);
}

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(T+1, -1));
    int ans = f(n-1, T, arr, dp);
    return (ans >= 1e9) ? -1 : ans;
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


âœ… Complexity:

Time: O(N*T)

Space: O(N*T) + O(N) (DP table + recursion).

ğŸ”¹ Step 3: Tabulation (Bottom-Up DP)

We build iteratively instead of recursion.

ğŸ“Œ Tabulation Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<vector<int>> dp(n, vector<int>(T+1, 0));

    // Base case
    for (int t = 0; t <= T; t++) {
        if (t % arr[0] == 0) dp[0][t] = t / arr[0];
        else dp[0][t] = 1e9;
    }

    // Fill table
    for (int i = 1; i < n; i++) {
        for (int t = 0; t <= T; t++) {
            int notTake = dp[i-1][t];
            int take = 1e9;
            if (arr[i] <= t) take = 1 + dp[i][t - arr[i]];
            dp[i][t] = min(notTake, take);
        }
    }

    int ans = dp[n-1][T];
    return (ans >= 1e9) ? -1 : ans;
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


âœ… Complexity:

Time: O(N*T)

Space: O(N*T)

ğŸ”¹ Step 4: Space Optimized Tabulation

We only need current row + previous row.
Even further, since â€œpickâ€ uses current row (dp[target - arr[i]]), we can reduce to a 1D array.

ğŸ“Œ Space-Optimized Code (C++)
#include <bits/stdc++.h>
using namespace std;

int minimumElements(vector<int>& arr, int T) {
    int n = arr.size();
    vector<int> dp(T+1, 1e9);

    // Base case
    for (int t = 0; t <= T; t++) {
        if (t % arr[0] == 0) dp[t] = t / arr[0];
    }

    // Build dp
    for (int i = 1; i < n; i++) {
        for (int t = 0; t <= T; t++) {
            int notTake = dp[t];
            int take = 1e9;
            if (arr[i] <= t) take = 1 + dp[t - arr[i]];
            dp[t] = min(notTake, take);
        }
    }

    return (dp[T] >= 1e9) ? -1 : dp[T];
}

int main() {
    vector<int> arr = {1, 2, 3};
    int T = 7;
    cout << minimumElements(arr, T);
}


âœ… Complexity:

Time: O(N*T)

Space: O(T)

ğŸ”¹ Dry Run Example

Input: arr = {1, 2, 3}, T = 7

Table filling (tabulation):

dp[0][t] = t (since only coin=1 works)

Row for coin=2:

dp[1][7] = min(dp[0][7]=7, 1+dp[1][5]=1+3=4) = 4

Row for coin=3:

dp[2][7] = min(dp[1][7]=4, 1+dp[2][4]=1+2=3) = 3 âœ…

Answer = 3 (e.g. 3+2+2).

ğŸ”¹ Edge Cases

X = 0 â†’ return 0 (no coins needed).

If no valid combo exists â†’ return -1.

If arr doesnâ€™t contain 1, some targets may be impossible.

Large inputs â†’ must use DP, recursion will TLE.

ğŸ”¹ Complexity Summary
Approach	Time	Space	Notes
Recursion	Exponential	O(N)	TLE
Memoization	O(N*T)	O(N*T)+O(N)	Top-down
Tabulation	O(N*T)	O(N*T)	Bottom-up
Space Optimized	O(N*T)	O(T)	Best
ğŸ”¹ Relation to Patterns

This is a classic Unbounded Knapsack problem.

Each coin = item

Weight = coin value

Can use unlimited times

Instead of maximizing value, we minimize the count.

Similar Problems:

Coin Change I (min coins)

Coin Change II (count ways)

Rod Cutting

Unbounded Knapsack

ğŸ”¹ Final Takeaways

Donâ€™t use greedy â†’ fails in non-uniform coins.

Start with recursion â†’ add memoization â†’ tabulation â†’ optimize space.

Base case (when ind==0): if divisible â†’ return quotient else âˆ.

Final answer: dp[n-1][T], return -1 if â‰¥ 1e9.
