3.Partition Set Into Two Subsets With Minimum Absolute Sum Difference (DP)
link: https://www.geeksforgeeks.org/problems/minimum-sum-partition3317/1
Problem Statement

Given an array ARR of N positive integers, partition it into two subsets such that the absolute difference of their sums is minimized.

Return: Minimum absolute difference of subset sums.

1. Key Observation

Let:

S = sum(ARR)

Subsets: S1 and S2

Absolute difference: |S1 - S2| = |S1 - (S - S1)| = |S - 2*S1|

✅ So we only need to find valid subset sums S1. The corresponding S2 = S - S1.

Valid S1 values are determined from Subset Sum DP.

2. Recursive Approach (Pick / Non-Pick)
Step 1: Define Problem

f(ind, target) → whether a subset exists in ARR[0..ind] with sum = target

Step 2: Base Cases

target == 0 → return true

ind == 0 → return arr[0] == target

Step 3: Choices at Index ind

Not Take: f(ind-1, target)

Take: f(ind-1, target-arr[ind]) (if arr[ind] <= target)

Return: taken || notTaken

3. Memoization (Top-Down DP)
Idea

Use DP table: dp[ind][target] to store results

Then scan the last row of the DP table to get all valid S1 values

Compute minimum absolute difference: |totSum - 2*S1|

Code (C++)
bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp){
    if(target==0) return dp[ind][target] = true;
    if(ind==0) return dp[ind][target] = (arr[0]==target);
    if(dp[ind][target]!=-1) return dp[ind][target];

    bool notTaken = subsetSumUtil(ind-1,target,arr,dp);
    bool taken = false;
    if(arr[ind]<=target) taken = subsetSumUtil(ind-1,target-arr[ind],arr,dp);

    return dp[ind][target] = notTaken || taken;
}

int minSubsetSumDifference(vector<int>& arr, int n){
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    vector<vector<int>> dp(n, vector<int>(totSum+1,-1));

    for(int i=0;i<=totSum;i++) subsetSumUtil(n-1,i,arr,dp);

    int mini = INT_MAX;
    for(int i=0;i<=totSum;i++){
        if(dp[n-1][i]){
            mini = min(mini, abs(totSum-2*i));
        }
    }
    return mini;
}


Time Complexity: O(NtotSum)
Space Complexity: O(NtotSum) + O(N) recursion stack

4. Tabulation (Bottom-Up DP)

Use dp[ind][target] boolean table

Base cases:

dp[i][0] = true (sum 0 always possible)

dp[0][arr[0]] = true (first element forms sum)

Transition:

dp[ind][target] = dp[ind-1][target] || (arr[ind]<=target ? dp[ind-1][target-arr[ind]] : false);


Scan last row to compute |totSum - 2*S1| minimum

Code (C++ Tabulation)
int minSubsetSumDifference(vector<int>& arr, int n){
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    vector<vector<bool>> dp(n, vector<bool>(totSum+1,false));

    for(int i=0;i<n;i++) dp[i][0] = true;
    if(arr[0]<=totSum) dp[0][arr[0]] = true;

    for(int ind=1; ind<n; ind++){
        for(int target=1; target<=totSum; target++){
            bool notTaken = dp[ind-1][target];
            bool taken = (arr[ind]<=target) ? dp[ind-1][target-arr[ind]] : false;
            dp[ind][target] = notTaken || taken;
        }
    }

    int mini = INT_MAX;
    for(int i=0;i<=totSum;i++){
        if(dp[n-1][i]) mini = min(mini, abs(totSum-2*i));
    }
    return mini;
}


Time Complexity: O(NtotSum)
Space Complexity: O(NtotSum)

5. Space Optimization

Only previous row is needed → use single array prev[]

Transition:

cur[target] = prev[target] || (arr[ind]<=target ? prev[target-arr[ind]] : false);


Scan prev at the end for minimum difference

Code (C++ Space Optimized)
int minSubsetSumDifference(vector<int>& arr, int n){
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    vector<bool> prev(totSum+1,false);
    prev[0] = true;
    if(arr[0]<=totSum) prev[arr[0]] = true;

    for(int ind=1; ind<n; ind++){
        vector<bool> cur(totSum+1,false);
        cur[0] = true;
        for(int target=1; target<=totSum; target++){
            bool notTaken = prev[target];
            bool taken = (arr[ind]<=target) ? prev[target-arr[ind]] : false;
            cur[target] = notTaken || taken;
        }
        prev = cur;
    }

    int mini = INT_MAX;
    for(int i=0;i<=totSum;i++){
        if(prev[i]) mini = min(mini, abs(totSum-2*i));
    }
    return mini;
}


Time Complexity: O(N*totSum)
Space Complexity: O(totSum)

6. Key Points

Absolute difference = |totSum - 2*S1|

Only one subset sum (S1) needs to be considered

Scan last row (or final DP array) for all valid S1

DP Approaches:

Recursion → Memoization → Tabulation → Space Optimization
