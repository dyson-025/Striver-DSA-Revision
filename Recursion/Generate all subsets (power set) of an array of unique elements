🔁 Generate all subsets (power set) of an array of unique elements
📥 Input: nums = [1, 2, 3]
📤 Output: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
✅ Tags: recursion, backtracking, subsets, array
📌 What's the base condition and decision choices in each recursion?
🧪 Dry run for nums = [1, 2]

🧠 Logic / Reasoning:
At each index, you have 2 choices:
Include nums[i]
Don’t include nums[i]
When you reach the end of array → push current subset to answer.
🔩 Code (Pass-by-Reference):
cpp
CopyEdit
void generateSubsets(int i, vector<int> &nums, vector<int> &temp, vector<vector<int>> &res) {
    if (i == nums.size()) {
        res.push_back(temp);
        return;
    }

    // Include current element
    temp.push_back(nums[i]);
    generateSubsets(i + 1, nums, temp, res);
    temp.pop_back(); // backtrack

    // Exclude current element
    generateSubsets(i + 1, nums, temp, res);
}
📞 Initial call:
cpp
CopyEdit
vector<vector<int>> res;
vector<int> temp;
generateSubsets(0, nums, temp, res);
🧪 Dry Run: nums = [1, 2]
pgsql
CopyEdit
Start: i=0, temp=[]
→ include 1 → temp=[1]
   → include 2 → temp=[1,2] → push
   → exclude 2 → temp=[1]   → push
→ exclude 1 → temp=[]
   → include 2 → temp=[2]   → push
   → exclude 2 → temp=[]    → push
✅ Final: [[], [1], [1,2], [2]]
🧠 Power Set = 2^n subsets
For n = 3, total = 2^3 = 8 subsets
🕒 Time Complexity: O(2^n)
📦 Space Complexity: O(n) for recursion stack
