ğŸ” Generate all subsets (power set) of an array of unique elements
ğŸ“¥ Input: nums = [1, 2, 3]
ğŸ“¤ Output: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
âœ… Tags: recursion, backtracking, subsets, array
ğŸ“Œ What's the base condition and decision choices in each recursion?
ğŸ§ª Dry run for nums = [1, 2]

ğŸ§  Logic / Reasoning:
At each index, you have 2 choices:
Include nums[i]
Donâ€™t include nums[i]
When you reach the end of array â†’ push current subset to answer.
ğŸ”© Code (Pass-by-Reference):
cpp
CopyEdit
void generateSubsets(int i, vector<int> &nums, vector<int> &temp, vector<vector<int>> &res) {
    if (i == nums.size()) {
        res.push_back(temp);
        return;
    }

    // Include current element
    temp.push_back(nums[i]);
    generateSubsets(i + 1, nums, temp, res);
    temp.pop_back(); // backtrack

    // Exclude current element
    generateSubsets(i + 1, nums, temp, res);
}
ğŸ“ Initial call:
cpp
CopyEdit
vector<vector<int>> res;
vector<int> temp;
generateSubsets(0, nums, temp, res);
ğŸ§ª Dry Run: nums = [1, 2]
pgsql
CopyEdit
Start: i=0, temp=[]
â†’ include 1 â†’ temp=[1]
   â†’ include 2 â†’ temp=[1,2] â†’ push
   â†’ exclude 2 â†’ temp=[1]   â†’ push
â†’ exclude 1 â†’ temp=[]
   â†’ include 2 â†’ temp=[2]   â†’ push
   â†’ exclude 2 â†’ temp=[]    â†’ push
âœ… Final: [[], [1], [1,2], [2]]
ğŸ§  Power Set = 2^n subsets
For n = 3, total = 2^3 = 8 subsets
ğŸ•’ Time Complexity: O(2^n)
ğŸ“¦ Space Complexity: O(n) for recursion stack
