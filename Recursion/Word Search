LeetCode 79: Word Search (Medium)
link: https://leetcode.com/problems/word-search/description/
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example:
arduino
CopyEdit
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"  
Output: true
ğŸ§  Can you explain the algorithm and dry run with backtracking?

ğŸ” Approach: Backtracking (DFS)
Try to start from every cell and explore in 4 directions (up, down, left, right).
Steps:
For each cell (i, j), if it matches the first character of word, call DFS.
In DFS:
Check if index == word.length() â†’ return true.
Boundary + char check.
Mark visited (temporarily change board[i][j] to #).
Explore 4 directions.
Backtrack (restore original character).
If any DFS call returns true â†’ word exists.
Time Complexity: O(N * M * 4^L)
N x M â†’ board size
L â†’ word length
4^L â†’ max DFS calls
Space: O(L) recursion stack
ğŸ§ª Dry Run (Anki-style)
Input:
mathematica
CopyEdit
board = [ 
  [A, B, C, E], 
  [S, F, C, S], 
  [A, D, E, E] 
], word = "ABCCED"
Start at (0,0) â†’ 'A' == word[0]
DFS â†’ mark (0,0) = '#'
Explore right (0,1) â†’ 'B' == word[1]
DFS â†’ mark (0,1) = '#'
Explore right (0,2) â†’ 'C' == word[2]
DFS â†’ mark (0,2) = '#'
Explore down (1,2) â†’ 'C' == word[3]
DFS â†’ mark (1,2) = '#'
Explore down (2,2) â†’ 'E' == word[4]
DFS â†’ mark (2,2) = '#'
Explore left (2,1) â†’ 'D' == word[5]
Word found âœ”ï¸
ğŸ’¡ Tip
Donâ€™t forget to restore board[i][j] after recursion for backtracking.

âŒ Dry Run â€“ Word Does Not Exist
Input:
txt
CopyEdit
board = [ 
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
], word = "ABCB"
Observation:
"A" â†’ (0,0)
"B" â†’ (0,1)
"C" â†’ (0,2)
Canâ€™t go to "B" again (already visited) â†’ âŒ Backtrack
Try other paths â†’ none work
ğŸ”š No valid path â†’ Word Not Found âŒ
ğŸ’» C++ Code (Clean & Commented)
cpp
CopyEdit
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int rows = board.size();
        int cols = board[0].size();

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (dfs(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }

private:
    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int idx) {
        // Base case: All characters matched
        if (idx == word.size()) return true;

        // Boundary & character mismatch check
        if (i < 0 || i >= board.size() ||
            j < 0 || j >= board[0].size() ||
            board[i][j] != word[idx]) return false;

        // Save the character and mark visited
        char temp = board[i][j];
        board[i][j] = '#';

        // Explore all 4 directions
        bool found = dfs(board, word, i + 1, j, idx + 1) ||
                     dfs(board, word, i - 1, j, idx + 1) ||
                     dfs(board, word, i, j + 1, idx + 1) ||
                     dfs(board, word, i, j - 1, idx + 1);

        // Backtrack
        board[i][j] = temp;

        return found;
    }
};
