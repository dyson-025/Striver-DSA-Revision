ğŸ” Recursion â€“ Generate Binary Strings without consecutive 1s
link: https://www.geeksforgeeks.org/problems/consecutive-1s-not-allowed1912/1
ğŸ“¥ Input: n = 3
ğŸ“¤ Output: ["000", "001", "010", "100", "101"]
âœ… Tags: recursion, binary, string, backtracking
How to avoid consecutive 1s? What should be the base and recursive steps?

ğŸ§  Idea:
Keep adding '0' freely.
Only add '1' if the last char is not '1' (to avoid 11).
ğŸ”© Code:
cpp
CopyEdit
void solve(int n, string s, vector<string> &res) {
    if (n == 0) {
        res.push_back(s);
        return;
    }
    solve(n - 1, s + "0", res);  // always allowed
    if (s.empty() || s.back() != '1')  // avoid consecutive 1s
        solve(n - 1, s + "1", res);
}
ğŸ“ Call it like:
cpp
CopyEdit
vector<string> res;
solve(n, "", res);
sort(res.begin(), res.end()); // lexicographic order
ğŸ§  Example:
n = 2 â†’ ["00", "01", "10"]
n = 3 â†’ ["000", "001", "010", "100", "101"]
ğŸ•’ Time Complexity: O(2^n) (but fewer due to skip of "11")
ğŸ“¦ Space: O(n) recursion + result array 

or

ğŸ”© Code (Pass-by-Reference):
cpp
CopyEdit
void solve(int n, string &s, vector<string> &res) {
    if (n == 0) {
        res.push_back(s);
        return;
    }

    // Add '0' (always allowed)
    s.push_back('0');
    solve(n - 1, s, res);
    s.pop_back();

    // Add '1' only if last char is not '1'
    if (s.empty() || s.back() != '1') {
        s.push_back('1');
        solve(n - 1, s, res);
        s.pop_back();
    }
}
ğŸ“ Call like this:
cpp
CopyEdit
vector<string> res;
string s;
solve(n, s, res);
sort(res.begin(), res.end());
ğŸ§ª Example:
n = 2 â†’ ["00", "01", "10"]
n = 3 â†’ ["000", "001", "010", "100", "101"]
ğŸ§  Why pass-by-reference?
Faster: avoids copying string and vector again and again.
Use s.pop_back() to undo choice â†’ backtracking.
Saves memory and improves recursion performance.
ğŸ•’ Time Complexity: O(2^n)
ğŸ“¦ Space: O(n) (recursion depth)
