Leetcode 1922 ‚Äì Count Good Numbers
link: https://leetcode.com/problems/count-good-numbers/description/
üß† A digit string is good if:
Digits at even indices (0, 2, 4, ...) are even ‚Üí {0, 2, 4, 6, 8} ‚Üí 5 options
Digits at odd indices (1, 3, 5, ...) are prime ‚Üí {2, 3, 5, 7} ‚Üí 4 options
üéØ Task:
Given an integer n, return the total number of good digit strings of length n, modulo 10‚Åπ + 7.
üìå Example:
Input: n = 4
Even indices: positions 0 and 2 ‚Üí 5 options each ‚Üí 5¬≤ = 25
Odd indices: positions 1 and 3 ‚Üí 4 options each ‚Üí 4¬≤ = 16
Total good strings = 25 * 16 = 400

class Solution {
public:
    long long mod = 1e9 + 7;

    long long power(long long x, long long y) {
        long long result = 1;
        x %= mod;
        while (y > 0) {
            if (y % 2 == 1) {
                result = (result * x) % mod;
            }
            x = (x * x) % mod;
            y /= 2;
        }
        return result;
    }

    int countGoodNumbers(long long n) {
        long long even_positions = (n + 1) / 2; // ceil(n / 2)
        long long odd_positions = n / 2;        // floor(n / 2)

        long long even_ways = power(5, even_positions); // 5 choices at even indices
        long long odd_ways = power(4, odd_positions);   // 4 choices at odd indices

        return (even_ways * odd_ways) % mod;
    }
};
üß† Logic Recap:
Total positions = n

Even-indexed positions ‚Üí ceil(n / 2) ‚Üí each has 5 choices

Odd-indexed positions ‚Üí floor(n / 2) ‚Üí each has 4 choices

Multiply the number of choices using fast exponentiation

‚è±Ô∏è Time Complexity:
O(log n) ‚Üí for each power(x, y) call
(we use it twice: once for 5^x and once for 4^y)

üß† Space Complexity:
O(1) ‚Üí constant extra space (no recursion, no additional data structures)
