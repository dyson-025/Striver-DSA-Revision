ğŸ’¡ Leetcode 50: Pow(x, n)
link: https://leetcode.com/problems/powx-n/description/
Implement pow(x, n) which calculates xâ¿.
ğŸ“Œ Constraints:
x âˆˆ (-100.0, 100.0)
n âˆˆ [âˆ’2Â³Â¹, 2Â³Â¹âˆ’1]
Either x â‰  0 or n > 0
âˆ’10â´ â‰¤ xâ¿ â‰¤ 10â´
Examples:
Input: x = 2.00000, n = 10 â†’ Output: 1024.00000
Input: x = 2.10000, n = 3 â†’ Output: 9.26100
Input: x = 2.00000, n = -2 â†’ Output: 0.25000
âœï¸ Implement efficiently.

ğŸ”‘ Idea: Binary Exponentiation (Fast Exponentiation)
Reduce time from O(n) â O(log n) using divide & conquer.
Handle negative n by computing reciprocal:
xâ»â¿ = 1 / xâ¿
âœ… C++ Code:
double myPow(double x, int n) {
    long long N = n;
    if (N < 0) {
        x = 1 / x;
        N = -N;
    }
    double result = 1;
    while (N > 0) {
        if (N % 2 == 1)
            result *= x;
        x *= x;
        N /= 2;
    }
    return result;
}
ğŸ§  Why Binary Exponentiation?
We divide the power by 2 at each step and square the base.
This reduces computation dramatically.
Handles large n and even negative powers properly.
Tags: Math, Binary Exponentiation, Divide and Conquer, Medium
Time: O(log n)
Space: O(1)
