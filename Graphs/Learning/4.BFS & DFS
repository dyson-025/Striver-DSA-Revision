ðŸ“˜ Depth First Search (DFS) â€“ Notes
ðŸ”¹ Definition

DFS explores a graph deeply: it goes along a path until no more unvisited neighbors remain, then backtracks.

ðŸ”¹ Algorithm (Steps)

Choose a start node.

Mark it visited and add to result.

Explore each unvisited neighbor recursively.

Backtrack when stuck, continue until all nodes are visited.

ðŸ”¹ Code (C++)
class Solution {
  private:
    void dfs(int node, vector<int> adj[], int vis[], vector<int>& res) {
        vis[node] = 1;
        res.push_back(node);
        for (auto it : adj[node]) {
            if (!vis[it]) dfs(it, adj, vis, res);
        }
    }
  public:
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        int vis[V] = {0};
        vector<int> res;
        dfs(0, adj, vis, res); // assuming start=0
        return res;
    }
};

ðŸ”¹ Complexity

Time: O(N + E)

Space: O(N) (recursion + visited + adjacency list)

ðŸ”¹ Use Cases

Pathfinding in mazes, puzzles.

Cycle detection in graphs.

Topological sort.

Tree traversals.

ðŸ”¹ Example

Graph:

0 -- 1
| \
2  3
|
4


DFS: 0 2 4 1 3

ðŸ“˜ Breadth First Search (BFS) â€“ Notes
ðŸ”¹ Definition

BFS explores a graph level by level using a queue (FIFO).

ðŸ”¹ Algorithm (Steps)

Choose a start node.

Mark visited and push into queue.

While queue not empty:

Pop front â†’ add to result.

Push all unvisited neighbors into queue.

Continue until queue is empty.

ðŸ”¹ Code (C++)
class Solution {
  public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        int vis[V] = {0};
        vis[0] = 1;
        queue<int> q;
        q.push(0);
        vector<int> bfs;

        while(!q.empty()) {
            int node = q.front(); q.pop();
            bfs.push_back(node);
            for (auto it : adj[node]) {
                if (!vis[it]) {
                    vis[it] = 1;
                    q.push(it);
                }
            }
        }
        return bfs;
    }
};

ðŸ”¹ Complexity

Time: O(N + E)

Space: O(N) (queue + visited + adjacency list)

ðŸ”¹ Use Cases

Shortest path in unweighted graphs.

Level order traversal in trees.

Checking bipartiteness.

Spreading phenomena (e.g., virus spread, network broadcast).

ðŸ”¹ Example

Graph:

0 -- 1 -- 2
|    |
4    3


BFS: 0 1 4 2 3

ðŸ“Š DFS vs BFS â€“ Comparison
Feature	DFS	BFS
Data Structure	Recursion / Stack	Queue (FIFO)
Traversal	Depth first (explores long paths)	Level by level
Order Example	0 2 4 1 3	0 1 4 2 3
Time Complexity	O(N + E)	O(N + E)
Space Complexity	O(N) (recursion stack)	O(N) (queue)
Path Finding	Doesnâ€™t guarantee shortest path	Finds shortest path in unweighted graphs
Applications	Cycle detection, Topological Sort, Backtracking problems	Shortest path, Network broadcasting, Bipartite checking
Nature	Recursive / Backtracking	Iterative / Level-wise

âœ… Quick Trick for Interview:

If the question involves shortest path / levels â†’ BFS.

If it involves complete exploration / recursion â†’ DFS.
