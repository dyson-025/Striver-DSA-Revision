ğŸ§© Detect Cycle in an Undirected Graph (Using BFS)
ğŸ”¸ Difficulty: Medium
ğŸ”¸ Time to solve: ~20 mins
ğŸ”¸ Pattern: Graph Traversal (BFS)
ğŸ“˜ Problem Statement

Given an undirected graph with V vertices and E edges, determine if it contains any cycle or not.
The graph may consist of multiple disconnected components.

ğŸ”¹ Input:

V: number of vertices (0 to V-1)

edges: list of pairs [u, v] denoting an undirected edge between u and v

ğŸ”¹ Output:

true (1) â†’ if cycle exists

false (0) â†’ if no cycle exists

ğŸ§  Example 1:
Input:
V = 8, E = 7
(No cycle present)
Output: 0

ğŸ§  Example 2:
Input:
V = 8, E = 6
Cycle exists: 4 â†’ 5 â†’ 6 â†’ 4
Output: 1

ğŸ’¡ Intuition

A cycle means we can start from a node and return to the same node through a different path.

In BFS traversal, we explore nodes level by level.
If during traversal, we find a node that is already visited and is not the parent â†’ that means weâ€™ve arrived through another path, hence a cycle exists.

âš™ï¸ Approach
Step-by-step plan:
1ï¸âƒ£ Build an adjacency list

For each edge [u, v], add v to adj[u] and u to adj[v]
(because itâ€™s undirected).

2ï¸âƒ£ Visited array

Maintain an array vis[V] initialized to 0.

3ï¸âƒ£ BFS traversal (for each component)

For every unvisited node, perform BFS:

Use a queue storing pairs {node, parent}.

Initially push {src, -1} (no parent for starting node).

Mark src as visited.

4ï¸âƒ£ BFS loop

Pop the front node {node, parent} from the queue.

Traverse all its adjacent nodes:

If not visited, push {adjNode, node} and mark visited.

If already visited and not equal to parent, â†’ Cycle Found!

5ï¸âƒ£ If BFS completes for all components without detecting a cycle â†’ return false.
ğŸ§¾ Code Implementation (C++)
#include <bits/stdc++.h>
using namespace std;

class Solution {
  private:
  bool detect(int src, vector<int> adj[], int vis[]) {
      vis[src] = 1; 
      queue<pair<int,int>> q; 
      q.push({src, -1});  // (node, parent)
      
      while(!q.empty()) {
          int node = q.front().first; 
          int parent = q.front().second; 
          q.pop(); 
          
          for(auto adjNode : adj[node]) {
              if(!vis[adjNode]) {
                  vis[adjNode] = 1; 
                  q.push({adjNode, node}); 
              }
              // If visited and not the parent â†’ cycle found
              else if(adjNode != parent) {
                  return true; 
              }
          }
      }
      return false; 
  }

  public:
    bool isCycle(int V, vector<int> adj[]) {
        int vis[V] = {0};  // visited array
        
        for(int i = 0; i < V; i++) {
            if(!vis[i]) {
                if(detect(i, adj, vis)) 
                    return true; 
            }
        }
        return false; 
    }
};

ğŸ§® Complexity Analysis
Aspect	Explanation	Complexity
Time Complexity	Each node and its adjacency list is processed once â†’ O(V + 2E) (2E because undirected edges counted twice)	O(V + E)
Space Complexity	Queue + visited array	O(V)
ğŸ” Dry Run Example
Graph edges:
edges = [[4,5], [5,6], [6,4], [1,2]]


Adjacency list:

1 -> 2
2 -> 1
4 -> 5,6
5 -> 4,6
6 -> 4,5

BFS Traversal:

Start BFS from node 4
â†’ queue = {(4, -1)}

Visit 4 â†’ push {(5,4), (6,4)}

Pop 5 â†’ see neighbor 6

6 already visited and parent != 5 â†’ âœ… Cycle detected (4â€“5â€“6â€“4)

âš¡ Key Observations

âœ… Works for disconnected graphs (each component checked)
âœ… Detects cycles using parent tracking
âœ… Doesnâ€™t falsely detect parent-child connection as a cycle
âœ… Non-recursive, safe for large graphs (no stack overflow risk)

ğŸ§© Edge Cases
Case	Example	Expected
Single node, no edge	V=1, E=0	No cycle
Multiple disconnected components	some cyclic, some not	Returns true
Tree-like structure	No back edge	No cycle
Fully connected triangle	3 nodes, 3 edges	Cycle exists
ğŸ§  Comparison (DFS vs BFS)
Feature	BFS	DFS
Implementation	Iterative (Queue)	Recursive / Stack
Parent tracking	Stored as pair in queue	Passed as function argument
Space use	O(V)	O(V) (recursion stack)
Suitable for large graphs	âœ… (no recursion limit)	âŒ (stack overflow risk)
ğŸ Final Takeaway

In an undirected graph, if during BFS traversal a node is found that has been visited and is not the parent, it implies a cycle exists.

ğŸ”¸ Time Complexity â†’ O(V + E)
ğŸ”¸ Space Complexity â†’ O(V)
ğŸ”¸ Algorithm â†’ BFS with Parent Tracking
