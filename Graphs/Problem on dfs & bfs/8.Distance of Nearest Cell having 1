ğŸ§  Problem Statement
link: https://leetcode.com/problems/01-matrix/

You are given a binary grid of size N x M consisting of 0s and 1s.
For each cell, you need to find the distance of the nearest cell having value 1.

Distance is measured using the Manhattan Distance formula:

Distance=âˆ£i1âˆ’i2âˆ£+âˆ£j1âˆ’j2âˆ£

Where:

(i1, j1) â†’ coordinates of current cell

(i2, j2) â†’ coordinates of the nearest 1

ğŸ“˜ Example
Example 1:

Input:

0 1 1 0
1 1 0 0
0 0 1 1


Output:

1 0 0 1
0 0 1 1
1 1 0 0


Explanation:

Cell (0,0) â†’ nearest 1 at (0,1) â†’ distance = 1

Cell (1,2) â†’ nearest 1 at (1,1) â†’ distance = 1

Cell (2,1) â†’ nearest 1 at (2,2) â†’ distance = 1

ğŸ’¡ Intuition

We need to find for each 0, how far is the nearest 1.

If we start BFS from each 0 individually â†’ O((NÃ—M)Â²) â†’ too slow âŒ

Instead, notice:

All 1s can be considered as starting points (sources).

From these sources, we can expand in all directions simultaneously (multi-source BFS).

The first time a cell is reached â†’ itâ€™s guaranteed to be the nearest 1 (since BFS spreads level by level). âœ…

So, we push all 1â€™s initially in queue with distance = 0 and then expand to all 0â€™s.

ğŸ§© Approach (Step-by-Step)
Step 1ï¸âƒ£: Initialization

Create:

vis[n][m] â†’ visited array (0 = not visited, 1 = visited)

dist[n][m] â†’ stores final distance for each cell

queue<pair<pair<int,int>,int>> â†’ BFS queue storing:

{{row, col}, distance}

Step 2ï¸âƒ£: Push all 1â€™s initially

Traverse the grid:

If grid[i][j] == 1:

Push {{i,j}, 0} into queue

Mark vis[i][j] = 1

Else:

vis[i][j] = 0

ğŸ‘‰ This is called multi-source BFS initialization.

Step 3ï¸âƒ£: BFS Traversal

While queue is not empty:

Pop front cell (r, c, steps)

Store dist[r][c] = steps

For each of its 4 neighbors (up, right, down, left):

If valid & unvisited:

Mark visited

Push { {nrow, ncol}, steps+1 } in queue

Step 4ï¸âƒ£: Direction Handling

We can define directions compactly:

int delrow[] = {-1, 0, +1, 0};
int delcol[] = {0, +1, 0, -1};


For each i in 0..3,
nrow = row + delrow[i],
ncol = col + delcol[i].

This covers:
â¡ï¸ Right, â¬…ï¸ Left, â¬†ï¸ Up, â¬‡ï¸ Down

Boundary check before visiting:

if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && vis[nrow][ncol] == 0)

ğŸ§® Dry Run Example
Input:
0 1 0
0 0 0
1 0 0

Step 1: Initialize queue with all 1â€™s

Queue â†’ [ ((0,1),0), ((2,0),0) ]

Step 2: BFS traversal
Step	Cell	Distance	Updated Cells
1	(0,1)	0	(0,0),(1,1),(0,2) â†’ dist=1
2	(2,0)	0	(1,0),(2,1) â†’ dist=1
3	(0,0)	1	
4	(1,1)	1	(1,2),(2,1),(0,1),(1,0)
5	(2,1)	1	(2,2),(1,1),(2,0)
â€¦	...	...	...

âœ… Final Distances:

1 0 1
1 1 2
0 1 2

âš™ï¸ Code (C++)
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<vector<int>> nearest(vector<vector<int>> grid) {
        int n = grid.size();
        int m = grid[0].size();

        vector<vector<int>> vis(n, vector<int>(m, 0));
        vector<vector<int>> dist(n, vector<int>(m, 0));
        queue<pair<pair<int,int>, int>> q;

        // Step 1: Multi-source initialization
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(grid[i][j] == 1) {
                    q.push({{i,j}, 0});
                    vis[i][j] = 1;
                }
            }
        }

        int delrow[] = {-1, 0, +1, 0};
        int delcol[] = {0, +1, 0, -1};

        // Step 2: BFS traversal
        while(!q.empty()) {
            int row = q.front().first.first;
            int col = q.front().first.second;
            int steps = q.front().second;
            q.pop();

            dist[row][col] = steps;

            for(int i=0; i<4; i++) {
                int nrow = row + delrow[i];
                int ncol = col + delcol[i];

                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m
                    && vis[nrow][ncol] == 0) {
                    vis[nrow][ncol] = 1;
                    q.push({{nrow, ncol}, steps+1});
                }
            }
        }
        return dist;
    }
};

int main() {
    vector<vector<int>> grid = {
        {0,1,1,0},
        {1,1,0,0},
        {0,0,1,1}
    };

    Solution obj;
    vector<vector<int>> ans = obj.nearest(grid);

    for(auto i: ans){
        for(auto j: i)
            cout << j << " ";
        cout << "\n";
    }
}

ğŸ§  Key Points to Remember

âœ… Use multi-source BFS, not DFS (DFS gives wrong distances).
âœ… Start BFS from all 1â€™s with distance 0.
âœ… BFS ensures minimum distance (as it goes level by level).
âœ… Maintain both visited and distance matrices.
âœ… Use direction arrays for cleaner code.
âœ… Never modify the original grid while using BFS â€” maintain separate vis and dist.

â±ï¸ Time Complexity (Real Estimation)
Step	Operation	Time
Initialization	Traverse full grid once	O(NÃ—M)
BFS Traversal	Each cell pushed/popped once	O(NÃ—M)
Neighbor Checks	4 directions per cell	O(4Ã—NÃ—M)

Total = O(NÃ—M + 4Ã—NÃ—M) â‰ˆ O(NÃ—M) âœ…
(Because constants are ignored in asymptotic notation.)

ğŸ’¾ Space Complexity (Real Estimation)
Component	Space
Visited array	O(NÃ—M)
Distance array	O(NÃ—M)
Queue (max all cells)	O(NÃ—M)

Total = O(3Ã—NÃ—M) â†’ O(NÃ—M) âœ…

ğŸš« Common Pitfalls

âŒ Using DFS â†’ gives incorrect minimum distances
âŒ Forgetting to mark vis when pushing into queue â†’ causes repetition
âŒ Starting BFS from 0s instead of 1s
âŒ Not using a queue of pairs (need coordinates + distance)

ğŸ§¾ Summary for Quick Revision
Concept	Explanation
Type	Multi-source BFS on matrix
Goal	Find distance to nearest 1 for every cell
Start Points	All cells with 1
Distance Formula	Manhattan distance
Traversal	BFS (Level order)
Directions	Up, Down, Left, Right
Time Complexity	O(N Ã— M)
Space Complexity	O(N Ã— M)
Data Structures	Queue, Visited matrix, Distance matrix
Key Property	BFS ensures minimum steps automatically
