ğŸ§© Problem Name: Surrounded Regions (Replace Oâ€™s with Xâ€™s)
link: https://leetcode.com/problems/surrounded-regions/
ğŸ§  Problem Statement

Given a matrix mat of size N Ã— M containing only 'O' and 'X',
you must replace all 'O' that are completely surrounded by 'X' on all four sides (up, down, left, right).

ğŸ‘‰ If an 'O' is connected to a boundary 'O', it cannot be replaced, because itâ€™s not fully surrounded.

ğŸ’¡ Example 1

Input:

X X X X
X O X X
X O O X
X O X X
X X O O


Output:

X X X X
X X X X
X X X X
X X X X
X X O O


âœ… Explanation:
Only the 'O's that are not connected to the boundary 'O' are surrounded and hence replaced.

ğŸ¯ Intuition

'O's on the boundary can never be surrounded, because at least one side is missing an 'X'.

Any 'O' connected (directly or indirectly) to a boundary 'O' also cannot be replaced.

Therefore:

Start from all boundary 'O's

Run DFS/BFS from each of them to mark all connected 'O's as â€œsafeâ€.

After traversal, any 'O' not marked safe â†’ must be surrounded â†’ replace it with 'X'.

âš™ï¸ Algorithm (DFS Approach)
Step 1ï¸âƒ£: Initialization

Create:

vis[n][m] â†’ visited matrix (0 = unvisited, 1 = visited)

Direction arrays:

int delrow[] = {-1, 0, +1, 0};
int delcol[] = {0, +1, 0, -1};

Step 2ï¸âƒ£: Traverse Boundary Cells

For every cell on the first row, last row, first column, last column:

If itâ€™s 'O' and not visited, call DFS.

This marks all connected 'O's as visited, meaning they cannot be flipped.

Step 3ï¸âƒ£: DFS Traversal

For each 'O':

Mark current cell as visited.

Explore all 4 directions (up, right, down, left).

If the neighbor is 'O' and unvisited â†’ call DFS recursively.

Step 4ï¸âƒ£: Replace Surrounded Regions

After all boundary-connected 'O's are marked safe:

Traverse the matrix again.

If a cell is 'O' and not visited, it means itâ€™s fully surrounded â†’ convert to 'X'.

ğŸ” Visual Dry Run Example
Input:
X X X X
X O O X
X X O X
O X X X

Step 1: Boundary Oâ€™s

Boundary O at (3,0) â†’ mark safe via DFS.

Step 2: DFS marking

(3,0) safe

No adjacent Oâ€™s, so stop.

Step 3: Remaining Oâ€™s

(1,1), (1,2), (2,2) are not connected to any boundary O â†’ flip to X.

Final Output:
X X X X
X X X X
X X X X
O X X X

ğŸ§  Why DFS Works Here

DFS explores deeply connected components â€” perfect for marking groups of 'O's connected to boundary 'O's.
Once all such â€œsafe regionsâ€ are marked, every unvisited 'O' must be fully enclosed â€” hence replace it.

ğŸ§® Pseudocode
for all boundary cells (i, j):
    if mat[i][j] == 'O' and not visited:
        dfs(i, j)

dfs(i, j):
    mark visited[i][j] = 1
    for each direction (up, down, left, right):
        if valid cell and mat[nrow][ncol] == 'O' and not visited:
            dfs(nrow, ncol)

for all cells (i, j):
    if mat[i][j] == 'O' and not visited:
        mat[i][j] = 'X'

ğŸ’» Full C++ Code
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    void dfs(int row, int col, vector<vector<int>> &vis, 
             vector<vector<char>> &mat, int delrow[], int delcol[]) {
        vis[row][col] = 1;
        int n = mat.size();
        int m = mat[0].size();

        for(int i = 0; i < 4; i++) {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m
               && !vis[nrow][ncol] && mat[nrow][ncol] == 'O') {
                dfs(nrow, ncol, vis, mat, delrow, delcol);
            }
        }
    }

public:
    vector<vector<char>> fill(int n, int m, vector<vector<char>> mat) {
        vector<vector<int>> vis(n, vector<int>(m, 0));
        int delrow[] = {-1, 0, +1, 0};
        int delcol[] = {0, +1, 0, -1};

        // Traverse 1st & last rows
        for(int j = 0; j < m; j++) {
            if(!vis[0][j] && mat[0][j] == 'O')
                dfs(0, j, vis, mat, delrow, delcol);
            if(!vis[n-1][j] && mat[n-1][j] == 'O')
                dfs(n-1, j, vis, mat, delrow, delcol);
        }

        // Traverse 1st & last columns
        for(int i = 0; i < n; i++) {
            if(!vis[i][0] && mat[i][0] == 'O')
                dfs(i, 0, vis, mat, delrow, delcol);
            if(!vis[i][m-1] && mat[i][m-1] == 'O')
                dfs(i, m-1, vis, mat, delrow, delcol);
        }

        // Convert unvisited 'O' â†’ 'X'
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(!vis[i][j] && mat[i][j] == 'O')
                    mat[i][j] = 'X';
            }
        }

        return mat;
    }
};

int main() {
    vector<vector<char>> mat = {
        {'X', 'X', 'X', 'X'}, 
        {'X', 'O', 'X', 'X'}, 
        {'X', 'O', 'O', 'X'}, 
        {'X', 'O', 'X', 'X'}, 
        {'X', 'X', 'O', 'O'}
    };

    Solution ob;
    vector<vector<char>> ans = ob.fill(5, 4, mat);

    for(auto &row : ans) {
        for(auto &ch : row) cout << ch << " ";
        cout << "\n";
    }
}

ğŸ§¾ Output
X X X X
X X X X
X X X X
X X X X
X X O O

ğŸ•’ Real Time Complexity Analysis
Operation	Cost
Traversing boundaries (rows + cols)	O(N + M)
DFS traversal	O(N Ã— M Ã— 4) = O(4NM)
Final replacement traversal	O(N Ã— M)

âœ… Total = O(N Ã— M)
(each cell visited at most once, 4 neighbors per cell = constant factor)

ğŸ’¾ Space Complexity
Component	Space
vis array	O(N Ã— M)
DFS recursive stack (worst case)	O(N Ã— M)
Matrix itself	O(N Ã— M)

âœ… Total = O(N Ã— M)

ğŸ§  Key Concepts Recap
Concept	Explanation
Type	DFS / Connected Components in a Grid
Goal	Replace surrounded Oâ€™s with Xâ€™s
Idea	Boundary Oâ€™s & their connected components are safe
Traversal	DFS (can also use BFS)
Directions	Up, Down, Left, Right
Start Points	Boundary Oâ€™s
Time Complexity	O(N Ã— M)
Space Complexity	O(N Ã— M)
Important Edge Case	Oâ€™s touching the boundary stay O
Similar Problems	Number of Islands, Flood Fill
âš ï¸ Common Mistakes

ğŸš« Replacing 'O' before marking safe ones â†’ will corrupt DFS.
ğŸš« Forgetting to start only from boundary Oâ€™s.
ğŸš« Not marking visited immediately â†’ causes infinite recursion.
ğŸš« Confusing DFS (recursion) vs BFS (queue) â€” both valid, but DFS is simpler here.

ğŸ§¾ Summary for Quick Revision
Step	Action	Purpose
1	Mark all boundary-connected Oâ€™s as visited using DFS	Safe cells
2	Traverse matrix	Replace unvisited Oâ€™s with X
3	Return matrix	Final result
