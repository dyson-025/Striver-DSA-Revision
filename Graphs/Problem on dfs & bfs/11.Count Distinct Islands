🌊 Count Distinct Islands — Complete Notes
link: https://www.geeksforgeeks.org/problems/number-of-distinct-islands/1
🧠 Problem Summary

You are given a binary grid of size N × M, containing 0s (water) and 1s (land).
You need to count the number of distinct islands present in the grid.

Two islands are considered same if one can be translated (moved up, down, left, right) to match the other — rotation and reflection are not allowed.

📘 Example
Input:
grid = [
  [1, 1, 0, 0],
  [1, 0, 0, 0],
  [0, 0, 1, 1],
  [0, 0, 1, 0]
]

Output:
1

Explanation:

There are two islands, but both have the same shape:

# #
#


→ So there is only one distinct island shape.

🧩 Key Concepts
Concept	Description
Island	Group of connected 1s (land)
Connection	Up, Down, Left, Right (4 directions)
Distinctness	Two islands are same if shape is same after translation
Normalization	Represent each island by its relative coordinates to remove positional differences
⚙️ Approach — Step-by-Step (DFS Method)
Step 1️⃣: Traverse the grid

Loop through every cell (i, j)

When you find 1 (land) that is not yet visited → it’s a new island

Step 2️⃣: Explore the island using DFS

Start DFS from (i, j)

For each connected land cell (x, y) in the island, record its relative position compared to the base (i, j):

relative = (x - i, y - j)


This converts the island shape into a position-independent pattern.

Step 3️⃣: Store the shape

After the DFS for one island finishes, store the vector of relative coordinates in a set.

set automatically removes duplicate shapes.

Step 4️⃣: Final answer = size of set

The number of distinct island shapes is simply the number of unique entries in the set.

🧮 Example Dry Run
Grid:
1 1 0
0 1 0
1 0 1

Process:

1️⃣ Island 1: starting at (0,0)

Cells = {(0,0), (0,1), (1,1)}

Relative positions (base 0,0):
→ [(0,0), (0,1), (1,1)]

2️⃣ Island 2: starting at (2,0)

Only (2,0) → relative [(0,0)]

3️⃣ Island 3: starting at (2,2)

Only (2,2) → relative [(0,0)]

✅ Distinct shapes = { [(0,0),(0,1),(1,1)], [(0,0)] }
→ Answer = 2

💻 Code (DFS Implementation)
class Solution {
  public:
    void dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis,
             vector<pair<int,int>>& shape, int base_i, int base_j) {
        
        int n = grid.size();
        int m = grid[0].size();
        vis[i][j] = 1;

        // store relative position
        shape.push_back({i - base_i, j - base_j});

        // 4-directional moves
        int dx[] = {-1, 1, 0, 0};
        int dy[] = {0, 0, -1, 1};

        for (int k = 0; k < 4; k++) {
            int ni = i + dx[k];
            int nj = j + dy[k];
            if (ni >= 0 && nj >= 0 && ni < n && nj < m &&
                grid[ni][nj] == 1 && !vis[ni][nj]) {
                dfs(ni, nj, grid, vis, shape, base_i, base_j);
            }
        }
    }

    int countDistinctIslands(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> vis(n, vector<int>(m, 0));
        set<vector<pair<int,int>>> uniqueShapes;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1 && !vis[i][j]) {
                    vector<pair<int,int>> shape;
                    dfs(i, j, grid, vis, shape, i, j);
                    uniqueShapes.insert(shape);
                }
            }
        }
        return uniqueShapes.size();
    }
};

🧾 Complexity Analysis
Type	Complexity	Explanation
Time (Worst Case)	O(N × M × log S)	N×M traversal + log factor for set insertion
Time (Typical Case)	≈ O(N × M)	S (unique shapes) ≪ N×M, so near-linear
Space	O(N × M)	For visited array + recursion stack + shapes
🔎 Real-Time Understanding
Scenario	Example	Real Complexity
Best Case	One big island	O(N × M)
Average Case	Few medium islands	O(N × M)
Worst Case	Every land cell is separate (all isolated 1s)	O(N × M × log(N × M))

✅ In practical grids, the runtime behaves linearly, i.e., O(N × M).

📊 Space Usage Breakdown
Component	Space
vis array	O(N × M)
DFS recursion stack	O(N × M) (worst)
Island shape vector	O(k) per island
Set of shapes	O(S × k)
Total	O(N × M)
⚠️ Common Mistakes
Mistake	Explanation
❌ Inserting into set outside DFS condition	Adds empty shapes
❌ Not normalizing (i - base_i, j - base_j)	Islands at different locations look different
❌ Using absolute coordinates	Position-sensitive shapes
❌ Not resetting shape vector	Carries previous island’s shape
❌ Wrong direction handling	Misses connected cells
🧠 Intuition Recap

Every island is a shape formed by connected land cells.
To compare two shapes, we ignore where they are placed and focus on relative positions from the starting cell.
Two islands are distinct if their relative patterns differ.

🧱 Visual Representation

Imagine the grid as below:

1 1 0
0 1 0
1 0 1


DFS 1 (starting 0,0) covers:

(0,0) (0,1) (1,1)


→ shape normalized from (0,0):
[(0,0), (0,1), (1,1)]

DFS 2 covers single cell (2,0): [(0,0)]

DFS 3 covers single cell (2,2): [(0,0)]

✅ Two unique shapes → Answer = 2

🧩 Related Variations (for practice)
Variant	Description
Number of Islands	Count all islands (no distinct check)
Number of Enclaves	Count land cells not reachable from boundary
Distinct Islands (8 Directions)	Include diagonal connections
Distinct Islands (BFS)	Same concept using iterative queue
🚀 Quick Revision Summary
Section	Key Idea
Algorithm Type	DFS on 2D grid
Core Concept	Shape normalization using relative coordinates
Storage	set<vector<pair<int,int>>>
Traversal Directions	4 (up, down, left, right)
Result	Number of unique shapes in set
Time Complexity	O(N × M × log S) ≈ O(N × M)
Space Complexity	O(N × M)
🧭 Real-World Analogy

Think of each island as a stamp pattern.
If two stamps look the same (even if placed in different positions), they represent the same shape.
Your goal is to count how many unique stamp patterns exist on the paper.

✅ Final Takeaway

Use DFS/BFS for island traversal.

Always normalize coordinates to ignore position.

Store each island’s relative pattern in a set for uniqueness.

Result = number of distinct shapes.

Typical runtime is linear, making this efficient even for large grids.
