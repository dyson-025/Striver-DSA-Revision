ğŸ§© Detect Cycle in an Undirected Graph (Using DFS)
ğŸ”¸ Difficulty: Medium
ğŸ”¸ Average Time: 20 minutes
ğŸ”¸ Pattern: Graph Traversal (DFS + Recursion)
ğŸ“˜ Problem Statement

Given an undirected graph with V vertices and E edges, determine whether it contains any cycle or not.
If even one connected component has a cycle, return true (or 1).

ğŸ”¹ Input:

V: number of vertices (0 to V-1)

edges: list of pairs [u, v] representing an undirected edge

ğŸ”¹ Output:

true / 1 â†’ if graph contains a cycle

false / 0 â†’ otherwise

ğŸ§  Example 1:
Input:
V = 8, E = 7
Output: No
Explanation:
No cycle in the graph.

ğŸ§  Example 2:
Input:
V = 8, E = 6
Cycle: 4 â†’ 5 â†’ 6 â†’ 4
Output: Yes

ğŸ’¡ Intuition

DFS (Depth First Search) explores the graph in-depth.
If during traversal, we encounter a node that:

has already been visited, and

is not the parent of the current node â†’
then we have discovered a cycle.

Why exclude the parent?
Because in an undirected graph, the parent node will always be a visited node â€” revisiting it doesnâ€™t mean a cycle.

âš™ï¸ Approach
Step-by-Step Plan
1ï¸âƒ£ Build adjacency list

For each edge [u, v], insert v into adj[u] and u into adj[v].

2ï¸âƒ£ Visited array

Create a vis[V] initialized to 0.

3ï¸âƒ£ DFS traversal (for each component)

For every unvisited node, call DFS recursively.

4ï¸âƒ£ DFS Function Logic

Mark the node as visited.

For each adjacent node:

If itâ€™s not visited, call DFS recursively.

If itâ€™s already visited and not the parent, â†’ cycle found.

Return false if no adjacent node causes a cycle.

5ï¸âƒ£ Return result

If any component returns true, the whole graph has a cycle.

ğŸ§¾ Code Implementation (C++)
#include <bits/stdc++.h>
using namespace std;

class Solution {
  private: 
    bool dfs(int node, int parent, int vis[], vector<int> adj[]) {
        vis[node] = 1; 
        // Visit all adjacent nodes
        for(auto adjacentNode: adj[node]) {
            // Case 1: If adjacent is unvisited
            if(!vis[adjacentNode]) {
                if(dfs(adjacentNode, node, vis, adj)) 
                    return true; 
            }
            // Case 2: If adjacent is visited and not parent
            else if(adjacentNode != parent) 
                return true; 
        }
        return false; 
    }

  public:
    // Function to detect cycle in an undirected graph.
    bool isCycle(int V, vector<int> adj[]) {
        int vis[V] = {0};  // initialize all as unvisited
        
        // handle multiple components
        for(int i = 0; i < V; i++) {
            if(!vis[i]) {
                if(dfs(i, -1, vis, adj)) 
                    return true; 
            }
        }
        return false; 
    }
};

// Example usage
int main() {
    // Example graph
    vector<int> adj[4] = {{}, {2}, {1, 3}, {2}};
    Solution obj;
    bool ans = obj.isCycle(4, adj);
    if (ans)
        cout << "1\n";
    else
        cout << "0\n";
    return 0;
}

ğŸ” Dry Run Example
Example:
V = 4, E = 3
edges = [[1,2], [2,3], [3,1]]


Adjacency List:

1 -> 2, 3
2 -> 1, 3
3 -> 2, 1

DFS Steps:

Start DFS(1, -1)

Visit 1 â†’ neighbors [2,3]

Go to 2 â†’ DFS(2, 1)

Visit 2 â†’ neighbors [1,3]

1 is parent â†’ ignore

3 is unvisited â†’ DFS(3, 2)

Visit 3 â†’ neighbors [2,1]

2 is parent â†’ ignore

1 is visited and not parent â†’ âœ… Cycle found

ğŸ§® Complexity Analysis
Aspect	Explanation	Complexity
Time Complexity	Each node and each edge is traversed once â†’ O(V + 2E) = O(V + E)	O(V + E)
Space Complexity	Recursion stack + visited array	O(V)
ğŸ§  Key Observations

âœ… Works for disconnected graphs (checks each component).
âœ… Uses parent to prevent false cycle detection.
âœ… DFS provides depth-based traversal, efficient for recursive checks.
âœ… Clean and elegant logic.

âš¡ Edge Cases
Case	Example	Expected Output
Single node, no edge	V=1, E=0	No
Tree-like structure (no cycle)	edges = [[0,1],[1,2],[2,3]]	No
Simple triangle	edges = [[0,1],[1,2],[2,0]]	Yes
Disconnected graph with one cyclic component	edges = [[0,1],[1,2],[2,0],[3,4]]	Yes
ğŸ§© Comparison: BFS vs DFS
Feature	BFS	DFS
Traversal Type	Level-order (queue)	Depth-order (recursion)
Parent Tracking	Stored in queue	Passed as parameter
Recursion	âŒ No	âœ… Yes
Space usage	Queue (O(V))	Recursion stack (O(V))
Preferred for	Large shallow graphs	Deep or recursive graphs
ğŸ Final Takeaway

A cycle exists in an undirected graph if during DFS traversal,
we reach an already visited node that is not the parent.

âœ… Algorithm: DFS with Parent Tracking
â± Time Complexity: O(V + E)
ğŸ’¾ Space Complexity: O(V)
ğŸ”¹ Best for: Recursive implementations, small/medium graphs
