üß© Problem: Number of Enclaves
link: https://leetcode.com/problems/number-of-enclaves/
üîç Statement

You are given a binary matrix grid of size N √ó M, where:

0 ‚Üí Sea cell

1 ‚Üí Land cell

A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.

You must find how many land cells are there from which it is impossible to walk off the boundary in any number of moves.

üí° Intuition

Any land (1) on the boundary is not an enclave because you can walk directly off the boundary.

Also, any land connected (4-directionally) to a boundary land is not an enclave (you can reach the boundary through it).

So, the idea is:

Start from all boundary land cells.

Use BFS (or DFS) to mark all reachable lands connected to the boundary.

Finally, count the remaining unvisited land cells ‚Äî those are the enclaves.

üß≠ Approach
‚úÖ Steps:

Initialize

Create a visited matrix of size N√óM, initialized to 0.

Create a queue for BFS.

Mark boundary land cells

Traverse all boundary cells:

If a cell is land (1), mark it as visited and push it into the queue.

BFS Traversal

Perform BFS from all boundary land cells:

Pop a cell (r, c) from the queue.

Move in 4 directions (up, right, down, left).

For each neighbor (nr, nc):

If it‚Äôs a valid unvisited land, mark visited and push into the queue.

Count enclaves

After BFS, traverse the grid again.

Count all cells that are land (1) and unvisited (vis[i][j] == 0).

‚öôÔ∏è Code (C++)
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numberOfEnclaves(vector<vector<int>> &grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> vis(n, vector<int>(m, 0));
        queue<pair<int,int>> q;

        // Step 1: Push boundary land cells into queue
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0 || j == 0 || i == n-1 || j == m-1) {
                    if (grid[i][j] == 1) {
                        q.push({i, j});
                        vis[i][j] = 1;
                    }
                }
            }
        }

        // Step 2: BFS traversal
        int delRow[] = {-1, 0, +1, 0};
        int delCol[] = {0, +1, 0, -1};

        while (!q.empty()) {
            int row = q.front().first;
            int col = q.front().second;
            q.pop();

            for (int i = 0; i < 4; i++) {
                int nrow = row + delRow[i];
                int ncol = col + delCol[i];
                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&
                    grid[nrow][ncol] == 1 && !vis[nrow][ncol]) {
                    q.push({nrow, ncol});
                    vis[nrow][ncol] = 1;
                }
            }
        }

        // Step 3: Count unvisited land cells (enclaves)
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1 && vis[i][j] == 0)
                    cnt++;
            }
        }
        return cnt;
    }
};

int main() {
    vector<vector<int>> grid = {
        {0, 0, 0, 0},
        {1, 0, 1, 0},
        {0, 1, 1, 0},
        {0, 0, 0, 0}
    };

    Solution obj;
    cout << obj.numberOfEnclaves(grid) << endl; // Output: 3
}

üß† Dry Run Example
Input:
0 0 0 0
1 0 1 0
0 1 1 0
0 0 0 0

Step 1: Mark boundary land

Only (1,0) is land on boundary ‚Üí mark it visited, enqueue (1,0).

Step 2: BFS

From (1,0) ‚Üí no connected land neighbors ‚Üí end BFS.

Step 3: Count unvisited land

Remaining unvisited land cells = (1,2), (2,1), (2,2) ‚Üí 3 enclaves

‚úÖ Output ‚Üí 3

üß© Important Concepts

4-directional movement:

delRow = [-1, 0, +1, 0]
delCol = [0, +1, 0, -1]


Why BFS?

BFS explores level by level and avoids deep recursion stack overflow for large grids.

DFS can also be used with recursion or stack.

‚è±Ô∏è Time Complexity (Realistic Analysis)
Step	Operation	Time
Boundary traversal	Check all cells	O(N*M)
BFS traversal	Visit each cell at most once	O(N*M)
Counting enclaves	Another full grid scan	O(N*M)
Total		‚úÖ O(N √ó M)

(4 directions checked per node, but treated as constant factor)

üíæ Space Complexity
Component	Space
Visited array	O(N*M)
Queue (max all land cells)	O(N*M)
Direction arrays + variables	O(1)
Total	‚úÖ O(N √ó M)
üß© Key Differences from Similar Problems
Problem	Traversal	Logic
Surrounded Regions	DFS	Convert surrounded ‚ÄòO‚Äôs to ‚ÄòX‚Äôs
Number of Enclaves	BFS	Count 1‚Äôs not connected to boundary
Number of Islands	DFS	Count disconnected land components
‚úÖ Final Summary
Concept	Explanation
Goal	Count land cells that cannot reach the boundary
Technique	BFS from boundary land cells
Key Step	Mark all boundary-connected lands as visited
Answer	Remaining unvisited land cells
Time Complexity	O(N √ó M)
Space Complexity	O(N √ó M)
Type	Graph traversal (Matrix BFS)
