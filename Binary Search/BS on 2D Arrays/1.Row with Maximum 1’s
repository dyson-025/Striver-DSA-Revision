ğŸ“’ Revision Notes â€“ Row with Maximum 1â€™s
link: https://www.geeksforgeeks.org/problems/row-with-max-1s0023/1
ğŸ”¹ Problem:

You are given an n x m binary matrix (only 0s and 1s).

Each row is sorted in ascending order.

Find the index of the row with the maximum number of 1â€™s.

If no 1 exists â†’ return -1.

If tie â†’ return row with smaller index.

ğŸ”¹ Brute Force Approach

Idea: Traverse every row â†’ count 1â€™s â†’ track max.

Steps:

For each row â†’ count 1â€™s with a loop.

Compare with cnt_max, update if larger.

Return index of row with max 1â€™s.

Time Complexity: O(n * m)

Space Complexity: O(1)

âœ”ï¸ Easy to implement but slow for large inputs.

ğŸ”¹ Optimized Approach (Binary Search)

Idea: Since rows are sorted, find first occurrence of 1 using binary search.

Formula:
number_of_ones = m - first_occurrence_index

Use lowerBound(1) to find first 1 in each row.

Compare counts and update index.

Steps:

Initialize cnt_max = 0, index = -1.

For each row:

Use lowerBound to get first 1.

Compute no. of 1â€™s = m - position.

If greater than cnt_max, update both.

Return index.

Time Complexity: O(n * log m)

Space Complexity: O(1)

âœ”ï¸ Much faster when m is large.

ğŸ”¹ Even More Optimized (Greedy â€“ Staircase Traversal)

Idea: Start from top-right corner and move smartly.

If you see 1 â†’ move left (to find earlier 1).

If you see 0 â†’ move down.

Keep track of row index whenever you move left.

Time Complexity: O(n + m)

Space Complexity: O(1)

ğŸ‘‰ Best solution for very large inputs.

ğŸ”¹ Edge Cases

All 0â€™s â†’ return -1.

Multiple rows with same max 1â€™s â†’ return smallest index.

Single row/column matrix.

ğŸ”¹ Quick Comparison
Approach	Time	Space	Notes
Brute Force	O(n*m)	O(1)	Simple but slow
Binary Search	O(n*log m)	O(1)	Uses row sorting
Staircase (Optimal)	O(n+m)	O(1)	Best choice

âœ… Key takeaway:

Use binary search if row size is big.

Use staircase method for best performance.
