ğŸ“’ Revision Notes â€“ Search in a Sorted 2D Matrix
 link: https://leetcode.com/problems/search-a-2d-matrix/description/
ğŸ”¹ Problem Statement

Given an N x M matrix mat:

Each row is sorted in non-decreasing order.

First element of a row > last element of previous row (matrix can be thought of as â€œrow-concatenated sortedâ€).

Given a target, check if it exists in the matrix.

Return true if present, else false.

ğŸ”¹ Approach 1: Brute Force
âœ… Idea

Traverse all elements.

Return true if target found, else false.

â±ï¸ Complexity

Time: O(N*M)

Space: O(1)

ğŸ§© C++ Code
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (matrix[i][j] == target) return true;
    return false;
}

ğŸ”¹ Approach 2: Row-wise Binary Search
âœ… Idea

Only one row can contain the target: matrix[i][0] <= target <= matrix[i][m-1].

Apply binary search only on that row.

â±ï¸ Complexity

Time: O(N + log M)

Space: O(1)

ğŸ§© C++ Code
bool binarySearch(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (nums[mid] == target) return true;
        else if (target > nums[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}

bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    for (int i = 0; i < n; i++) {
        if (matrix[i][0] <= target && target <= matrix[i][m-1])
            return binarySearch(matrix[i], target);
    }
    return false;
}

ğŸ”¹ Approach 3: Treat Matrix as 1D Sorted Array (Optimal)
âœ… Idea

Conceptually flatten the matrix into 1D sorted array.

Apply binary search on [0, N*M-1].

Map 1D index â†’ 2D indices:

row = idx / M
col = idx % M

â±ï¸ Complexity

Time: O(log(N*M))

Space: O(1)

ğŸ§© C++ Code
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    int low = 0, high = n * m - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        int row = mid / m, col = mid % m;
        if (matrix[row][col] == target) return true;
        else if (matrix[row][col] < target) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}

ğŸ”¹ Approach 4: Diagonal / Staircase Search
âœ… Idea

Start top-right corner (0, M-1).

Compare element with target:

If equal â†’ return true.

If element > target â†’ move left (j--).

If element < target â†’ move down (i++).

Continue until out of bounds.

This works for row-wise and column-wise sorted matrices.

â±ï¸ Complexity

Time: O(N + M)

Space: O(1)

ğŸ§© C++ Code
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    int i = 0, j = m - 1; // start top-right
    while (i < n && j >= 0) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] > target) j--; // move left
        else i++; // move down
    }
    return false;
}

ğŸ”¹ Dry-run Example (Staircase)

Matrix:

1  2  3  4
5  6  7  8
9 10 11 12


Target = 8

Steps:

Start (0,3) â†’ 4 < 8 â†’ move down (1,3)

(1,3) â†’ 8 == 8 â†’ found â†’ return true

ğŸ”¹ Comparison Table
Approach	Time Complexity	Space Complexity	Notes
Brute Force	O(N*M)	O(1)	Simple, slow for large matrices
Row-wise Binary Search	O(N + log M)	O(1)	Only binary search in candidate row
1D Flatten Binary Search	O(log(N*M))	O(1)	Best if matrix is fully sorted row-wise
Diagonal / Staircase Search	O(N + M)	O(1)	Works even if only rows & cols sorted
ğŸ”¹ Key Takeaways

Brute force â†’ only for small matrices or testing.

Binary search approaches â†’ best when matrix is row-concatenated sorted.

Diagonal/staircase search â†’ best for row & column sorted matrices.

Mapping 1D index â†’ 2D index:

row = idx / M
col = idx % M
