ğŸ”‘ Problem Statement
https://leetcode.com/problems/next-greater-element-i/description/
Given two arrays:

nums1 (subset of nums2)

nums2 (unique elements, larger superset)

For each element in nums1, find the Next Greater Element (NGE) in nums2.

If no greater element exists â†’ return -1.

âš¡ Intuition

Brute force: For each element in nums1, search its next greater in nums2. â†’ O(n1 * n2) (too slow).

Optimized:

Process nums2 from right to left with a monotonic decreasing stack.

Store next greater for every element in a map.

Answer queries from nums1 using the map.

ğŸ› ï¸ Approach (Used in Code)

Traverse nums2 backwards.

Maintain stack st (stores candidates for "next greater").

While top â‰¤ current element â†’ pop (they canâ€™t be next greater).

If stack empty â†’ next greater = -1.

Else â†’ top of stack is next greater.

Save mapping in unordered_map.

Build result for nums1 using the map.

â±ï¸ Complexity

Time:

Each element pushed/popped once â†’ O(n2)

Lookup for nums1 â†’ O(n1)

Total: O(n1 + n2)

Space:

Stack + HashMap â†’ O(n2)

âœ… Key Points to Remember

Use monotonic stack when asked about "next greater / smaller element".

Traverse from right to left for "next greater".

Map ensures O(1) lookup for nums1.

ğŸ‘‰ Quick dry run:
nums1 = [4,1,2], nums2 = [1,3,4,2]

Map = {1â†’3, 3â†’4, 4â†’-1, 2â†’-1}

Result = [-1, 3, -1]

code:

class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> mpp;   // stores next greater element of each number in nums2
        stack<int> st;                 // monotonic decreasing stack
        int n2 = nums2.size();

        // Traverse nums2 from right to left
        for (int i = n2 - 1; i >= 0; i--) {
            // Pop smaller or equal elements (not useful for next greater)
            while (!st.empty() && st.top() <= nums2[i]) {
                st.pop();
            }

            // If stack empty â†’ no greater element
            if (st.empty()) {
                mpp[nums2[i]] = -1;
            } 
            else {
                mpp[nums2[i]] = st.top();  // top is next greater
            }

            // Push current element into stack
            st.push(nums2[i]);
        }

        // Build result for nums1 from the map
        vector<int> result;
        for (int num : nums1) {
            result.push_back(mpp[num]);
        }

        return result;
    }
};
