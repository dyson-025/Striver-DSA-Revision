ğŸ”¥ Next Smaller Element (NSE) â€“ Revision Notes
ğŸ“ Problem: https://www.geeksforgeeks.org/problems/immediate-smaller-element1142/1

Given an array arr[].

For each element, find the Next Smaller Element (NSE) on its right side.

If no smaller element exists â†’ return -1.

âš¡ Intuition

Yeh bhi monotonic stack ka direct application hai (same jaise Next Greater Element).

Bas condition reverse karni hai:

NGE â†’ pop while st.top() <= arr[i].

NSE â†’ pop while st.top() >= arr[i].

ğŸ› ï¸ Approach

Traverse array from right to left.

Maintain a monotonic increasing stack (store only potential smaller elements).

While stack not empty and st.top() >= arr[i] â†’ pop.

If stack empty â†’ NSE = -1.
Else â†’ st.top() is NSE.

Push arr[i] into stack.

â±ï¸ Complexity

Time: O(n) (each element pushed/popped at most once).

Space: O(n) (stack + result).

âœ… Dry Run Example

arr = [4, 8, 5, 2, 25]

Traverse right â†’ left:

i=4 (25): stack empty â†’ NSE=-1 â†’ push 25
i=3 (2):  stack=[25], top=25>=2 â†’ pop â†’ empty â†’ NSE=-1 â†’ push 2
i=2 (5):  stack=[2], top=2<5 â†’ NSE=2 â†’ push 5
i=1 (8):  stack=[2,5], pop 5>=8? no, pop 2>=8? no â†’ NSE=5 â†’ push 8
i=0 (4):  stack=[2,5,8], pop 8>=4 â†’ pop 8, pop 5>=4 â†’ pop 5 â†’ NSE=2 â†’ push 4


â¡ï¸ Result = [2, 5, 2, -1, -1]

ğŸ§© Clean Code
class Solution {
public:
    vector<int> nextSmallerElement(vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);
        stack<int> st;

        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && st.top() >= arr[i]) {
                st.pop();
            }

            if (!st.empty()) {
                result[i] = st.top();
            }

            st.push(arr[i]);
        }
        return result;
    }
};

ğŸ“Œ Quick Rules (Revision)
Variation	Direction	Condition in while loop	Stack type
Next Greater	Right â†’ Left	st.top() <= arr[i]	Monotonic Decreasing
Next Smaller	Right â†’ Left	st.top() >= arr[i]	Monotonic Increasing
Prev Greater	Left â†’ Right	st.top() <= arr[i]	Monotonic Decreasing
Prev Smaller	Left â†’ Right	st.top() >= arr[i]	Monotonic Increasing

ğŸ‘‰ One golden line:

Greater â†’ use <=

Smaller â†’ use >=

Next â†’ traverse right â†’ left

Previous â†’ traverse left â†’ right
