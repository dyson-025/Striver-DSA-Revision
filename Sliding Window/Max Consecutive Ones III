ğŸƒ Revision Card: Max Consecutive Ones III
ğŸ“Œ Problem link: https://leetcode.com/problems/max-consecutive-ones-iii/

Given a binary array nums and an integer k, return the length of the longest subarray containing only 1s after flipping at most k zeros.

Example:

Input: nums = [1,1,0,0,1,1,1,0,1], k = 2  
Output: 7  
Explanation: We can flip the two zeros at indices 2 and 3 â†’ longest subarray of 1s = [1,1,1,1,1,1,1]

ğŸ”¹ Approach 1: Brute Force (O(nÂ²))

Try all subarrays.

Count zeros â†’ if â‰¤ k, update max length.

Time: O(nÂ²), Space: O(1).

int longestOnes(vector<int>& nums, int k) {
    int n = nums.size(), res = 0;
    for (int i = 0; i < n; i++) {
        int zeros = 0;
        for (int j = i; j < n; j++) {
            if (nums[j] == 0) zeros++;
            if (zeros > k) break;
            res = max(res, j - i + 1);
        }
    }
    return res;
}

ğŸ”¹ Approach 2: Sliding Window (while â€“ Most Optimal, O(n))

Two pointers l and r.

Count zeros in window.

If zeros > k â†’ shrink from left until valid.

Track max length.

int longestOnes(vector<int>& nums, int k) {
    int l = 0, zeros = 0, res = 0;
    for (int r = 0; r < nums.size(); r++) {
        if (nums[r] == 0) zeros++;
        while (zeros > k) {
            if (nums[l] == 0) zeros--;
            l++;
        }
        res = max(res, r - l + 1);
    }
    return res;
}

ğŸ”¹ Approach 3: Sliding Window (if variant, O(n))

Similar to Approach 2.

Instead of shrinking fully (while), shrink only once with if.

Still works but less intuitive.

int longestOnes(vector<int>& nums, int k) {
    int l = 0, zeros = 0, res = 0;
    for (int r = 0; r < nums.size(); r++) {
        if (nums[r] == 0) zeros++;
        if (zeros > k) { // shrink once
            if (nums[l] == 0) zeros--;
            l++;
        }
        res = max(res, r - l + 1);
    }
    return res;
}

ğŸ¯ Summary Table
Approach	Idea	Time	Space	Usefulness
Brute Force	Check all subarrays	O(nÂ²)	O(1)	Only for basics
Sliding Window (while)	Maintain valid window	O(n)	O(1)	âœ… Best & expected
Sliding Window (if)	Shrink once	O(n)	O(1)	âœ… Alternate variant
