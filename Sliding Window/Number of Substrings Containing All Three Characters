ğŸ“ Revision Card: Number of Substrings Containing All Three Characters
ğŸ”¹ Problem link: https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/

You are given a string s consisting only of 'a', 'b', and 'c'.
Return the number of substrings that contain at least one 'a', one 'b', and one 'c'.

âœ… Approach 1: Better Approach (O(nÂ²))
ğŸ”¸ Intuition

Fix a starting point i.

Extend the substring towards the right (j from i to n-1).

Track counts of 'a','b','c'.

The first time you find all three â†’ every longer substring starting at i will also contain all three.

So you can add (n - j) to the answer and break (no need to go further for that i).

ğŸ”¸ Example Walkthrough ("abcabc")

Start at i=0:

j=0 â†’ "a" (not valid),

j=1 â†’ "ab" (not valid),

j=2 â†’ "abc" âœ… â†’ add (6-2)=4.

Start at i=1:

j=1 â†’ "b",

j=2 â†’ "bc",

j=3 â†’ "bca" âœ… â†’ add (6-3)=3.

Continue similarly â†’ total = 10.

ğŸ”¸ Code
int numberOfSubstrings(string s) {
    int n = s.size(), ans = 0;
    for (int i = 0; i < n; i++) {
        int cnt[3] = {0, 0, 0};
        for (int j = i; j < n; j++) {
            cnt[s[j]-'a']++;
            if (cnt[0] && cnt[1] && cnt[2]) {
                ans += (n - j);
                break;
            }
        }
    }
    return ans;
}

ğŸ”¸ Complexity

Outer loop = n.

Inner loop = up to n.

But breaks early when valid substring found â†’ much faster than naive.

Time: O(nÂ²) worst-case.

Space: O(1).

âœ… Approach 2: Last Occurrence Trick (Optimal O(n))
ğŸ”¸ Intuition

Think in terms of ending index of a substring.

For substring ending at i, when do we know itâ€™s valid?
â†’ When all three chars 'a','b','c' have appeared before or at i.

The earliest valid start is just after the minimum of the last seen indices of 'a','b','c'.

So the number of valid substrings ending at i = min(lastA, lastB, lastC) + 1.

ğŸ”¸ Example Walkthrough ("abcabc")

At i=0 â†’ "a" â†’ not valid.

At i=1 â†’ "ab" â†’ not valid.

At i=2 â†’ "abc" â†’ last = [0,1,2] â†’ min=0 â†’ add 0+1=1.

At i=3 â†’ "abca" â†’ last = [3,1,2] â†’ min=1 â†’ add 1+1=2.

At i=4 â†’ "abcab" â†’ last = [3,4,2] â†’ min=2 â†’ add 2+1=3.

At i=5 â†’ "abcabc" â†’ last = [3,4,5] â†’ min=3 â†’ add 3+1=4.

Total = 10 âœ….

ğŸ”¸ Code
int numberOfSubstrings(string s) {
    vector<int> last(3, -1);  // last indices of a,b,c
    int ans = 0;
    for (int i = 0; i < s.size(); i++) {
        last[s[i]-'a'] = i;
        if (last[0] != -1 && last[1] != -1 && last[2] != -1)
            ans += 1 + min({last[0], last[1], last[2]});
    }
    return ans;
}

ğŸ”¸ Complexity

Single pass â†’ O(n).

Only 3 indices tracked â†’ O(1) space.

ğŸ”¹ Complexity Comparison
Approach	Time Complexity	Space Complexity	Notes
O(nÂ²) Better	O(nÂ²)	O(1)	Good for explaining step by step
Last Occurrence Trick	O(n)	O(1)	Elegant & Optimal
âš¡ Interview Tips

Always start with O(nÂ²) (easy to derive).

Then say: â€œBut we can do better by focusing on the last occurrence of each character.â€

End with the optimal O(n) solution.

If time, do a dry run on "abcabc" to impress.
