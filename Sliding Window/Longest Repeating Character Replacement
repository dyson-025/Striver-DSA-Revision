🃏 Revision Card: Longest Repeating Character Replacement (Leetcode 424)
📌 Problem : https://leetcode.com/problems/longest-repeating-character-replacement/

Given a string s and an integer k, you may change at most k characters in the string.
Return the length of the longest substring containing the same letter after at most k replacements.

Example:

Input: s = "AABABBA", k = 1  
Output: 4
Explanation: Replace one 'B' → "AAAA"

🔹 Approach 1: Brute Force (O(n²))

For each substring, count frequencies.

If (window size - maxFreq) <= k → valid.

Keep max length.

⚠️ Works but too slow.

🔹 Approach 2: Sliding Window (Recompute maxFreq each time)

Maintain window [l, r] with frequency map.

Each time, calculate maxFreq from map (O(26)).

If (window size - maxFreq) > k, shrink left.

int characterReplacement(string s, int k) {
    vector<int> count(26, 0);
    int l = 0, res = 0;
    
    for (int r = 0; r < s.size(); r++) {
        count[s[r] - 'A']++;
        
        // recompute maxFreq every time
        int maxFreq = *max_element(count.begin(), count.end());
        
        while ((r - l + 1) - maxFreq > k) {
            count[s[l] - 'A']--;
            l++;
            maxFreq = *max_element(count.begin(), count.end());
        }
        
        res = max(res, r - l + 1);
    }
    return res;
}


Time: O(26 * n) → still O(n), but slower in practice.

Space: O(26).

🔹 Approach 3: Optimal Sliding Window (Don’t Recompute Every Time ✅)

Keep a maxFreq variable updated only when we add a new character.

Never decrease it when shrinking → it may become “stale”, but that’s fine.

Why it works:

The moment (window size - maxFreq) > k, we shrink, so invalid windows don’t increase res.

The maximum valid length has already been recorded.

When a new higher maxFreq is reached, window becomes valid again.

int characterReplacement(string s, int k) {
    vector<int> count(26, 0);
    int l = 0, maxFreq = 0, res = 0;
    
    for (int r = 0; r < s.size(); r++) {
        count[s[r] - 'A']++;
        maxFreq = max(maxFreq, count[s[r] - 'A']);
        
        while ((r - l + 1) - maxFreq > k) {
            count[s[l] - 'A']--;
            l++;
        }
        
        res = max(res, r - l + 1);
    }
    return res;
}


Time: O(n)

Space: O(26) ~ O(1)

✅ Best solution.

🔹 Dry Run (s = "AABABBA", k = 1)

At r=3 ("AABA"), window length = 4, maxFreq=3 → valid.

At r=4 ("AABAB"), length=5, maxFreq=3 → needs 2 replacements, invalid → shrink.

Window shrinks, but maxFreq stays 3 (even though actual max in window might be 2).

That’s fine because we already recorded the max valid length (=4).

Later, new frequencies update maxFreq again.

👉 Key Trick: Not reducing maxFreq doesn’t harm correctness, since invalid windows are never used for result — they only force shrinking until valid again.

🎯 Summary
Approach	Idea	Time	Space	Usefulness
Brute Force	Try all substrings	O(n²)	O(26)	Basic only
Sliding Window (recompute maxFreq)	Update freq fully	O(26·n)	O(26)	Correct but slower
Optimal Sliding Window	Keep maxFreq ever seen	O(n)	O(26)	✅ Best & expected
