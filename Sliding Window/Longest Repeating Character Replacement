ğŸƒ Revision Card: Longest Repeating Character Replacement (Leetcode 424)
ğŸ“Œ Problem : https://leetcode.com/problems/longest-repeating-character-replacement/

Given a string s and an integer k, you may change at most k characters in the string.
Return the length of the longest substring containing the same letter after at most k replacements.

Example:

Input: s = "AABABBA", k = 1  
Output: 4
Explanation: Replace one 'B' â†’ "AAAA"

ğŸ”¹ Approach 1: Brute Force (O(nÂ²))

For each substring, count frequencies.

If (window size - maxFreq) <= k â†’ valid.

Keep max length.

âš ï¸ Works but too slow.

ğŸ”¹ Approach 2: Sliding Window (Recompute maxFreq each time)

Maintain window [l, r] with frequency map.

Each time, calculate maxFreq from map (O(26)).

If (window size - maxFreq) > k, shrink left.

int characterReplacement(string s, int k) {
    vector<int> count(26, 0);
    int l = 0, res = 0;
    
    for (int r = 0; r < s.size(); r++) {
        count[s[r] - 'A']++;
        
        // recompute maxFreq every time
        int maxFreq = *max_element(count.begin(), count.end());
        
        while ((r - l + 1) - maxFreq > k) {
            count[s[l] - 'A']--;
            l++;
            maxFreq = *max_element(count.begin(), count.end());
        }
        
        res = max(res, r - l + 1);
    }
    return res;
}


Time: O(26 * n) â†’ still O(n), but slower in practice.

Space: O(26).

ğŸ”¹ Approach 3: Optimal Sliding Window (Donâ€™t Recompute Every Time âœ…)

Keep a maxFreq variable updated only when we add a new character.

Never decrease it when shrinking â†’ it may become â€œstaleâ€, but thatâ€™s fine.

Why it works:

The moment (window size - maxFreq) > k, we shrink, so invalid windows donâ€™t increase res.

The maximum valid length has already been recorded.

When a new higher maxFreq is reached, window becomes valid again.

int characterReplacement(string s, int k) {
    vector<int> count(26, 0);
    int l = 0, maxFreq = 0, res = 0;
    
    for (int r = 0; r < s.size(); r++) {
        count[s[r] - 'A']++;
        maxFreq = max(maxFreq, count[s[r] - 'A']);
        
        while ((r - l + 1) - maxFreq > k) {
            count[s[l] - 'A']--;
            l++;
        }
        
        res = max(res, r - l + 1);
    }
    return res;
}


Time: O(n)

Space: O(26) ~ O(1)

âœ… Best solution.

ğŸ”¹ Dry Run (s = "AABABBA", k = 1)

At r=3 ("AABA"), window length = 4, maxFreq=3 â†’ valid.

At r=4 ("AABAB"), length=5, maxFreq=3 â†’ needs 2 replacements, invalid â†’ shrink.

Window shrinks, but maxFreq stays 3 (even though actual max in window might be 2).

Thatâ€™s fine because we already recorded the max valid length (=4).

Later, new frequencies update maxFreq again.

ğŸ‘‰ Key Trick: Not reducing maxFreq doesnâ€™t harm correctness, since invalid windows are never used for result â€” they only force shrinking until valid again.

ğŸ¯ Summary
Approach	Idea	Time	Space	Usefulness
Brute Force	Try all substrings	O(nÂ²)	O(26)	Basic only
Sliding Window (recompute maxFreq)	Update freq fully	O(26Â·n)	O(26)	Correct but slower
Optimal Sliding Window	Keep maxFreq ever seen	O(n)	O(26)	âœ… Best & expected
